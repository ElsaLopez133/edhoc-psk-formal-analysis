/*
 * Protocol:   EDHOC-PSK
 * Source:     draft-ietf-lake-edhoc-psk
 * Model:      Fixed for concurrent sessions
*/

theory edhoc_psk_sapic

begin

builtins: diffie-hellman, hashing, xor

functions:
  method_four/0, length/0,
  hash_length/0, key_length/0, iv_length/0, plaintext_length/0, aead_length/0,
  edhoc_kdf/4,
  aeadenc/4, aeaddec/4 [destructor],
  wrap/1,
  hash/1, hkdfextract/2, hkdfexpand/2,
  encxor/2, decxor/2 [destructor],

  // Credential modeling functions
  make_cred/2,        // make_cred(subject_id, psk) -> credential
  get_subject/1,      // get_subject(credential) -> subject_id
  make_id/3,           // make_id(cred_i, cred_r, psk) -> ID_CRED_PSK
  get_cred_i/1 [destructor],  // get_cred_i(ID_CRED_PSK) -> cred_i
  get_cred_r/1 [destructor],  // get_cred_r(ID_CRED_PSK) -> cred_r
  get_psk/1 [destructor]      // get_psk(ID_CRED_PSK) -> psk

equations:
  aeaddec(aeadenc(m,k,r,ad),k,r,ad) = m,
  decxor(encxor(m,k),k) = m,
  get_subject(make_cred(subject, psk)) = subject,
  get_cred_i(make_id(cred_i, cred_r, psk)) = cred_i,
  get_cred_r(make_id(cred_i, cred_r, psk)) = cred_r,
  get_psk(make_id(cred_i, cred_r, psk)) = psk

/* -------------------- Initiator -------------------- */
let I(~cid, method, ID_CRED_PSK) =
  in(<suitesI,C_I,EAD_1>);
  event MethodOk(method);

  new ~X;
  new ~EAD_3;

  event LeakShare(~X);
  event CompromiseShare(~X);
  event LeakEAD(~EAD_3);

  let CRED_I = get_cred_i(ID_CRED_PSK) in
  let CRED_R = get_cred_r(ID_CRED_PSK) in
  let psk    = get_psk(ID_CRED_PSK) in
  let subject_i = get_subject(CRED_I) in
  let subject_r = get_subject(CRED_R) in

  event Start_I(~cid, method, subject_i);

  let G_X = 'g'^~X in
  let m1 = <method,suitesI,G_X,C_I,EAD_1> in
  out(m1);

  in(m2);
  let < G_Y, CIPHERTEXT_2 > = m2 in
  let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
  let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in

  let G_YX = G_Y^~X in
  let PRK_2e = hkdfextract(TH_2, G_YX) in
  let KEYSTREAM_2A = edhoc_kdf(PRK_2e,'tzero',TH_2,plaintext_length) in
  let plaintext_2 = decxor(CIPHERTEXT_2, KEYSTREAM_2A) in
  let < C_R, EAD_2> = plaintext_2 in

  if method = method_four() then (
    let PRK_3e2m = PRK_2e in
    event DerivedIShared(G_YX);

    let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
    let SALT_4e3m = edhoc_kdf(PRK_3e2m, 'five', TH_3, hash_length) in
    let PRK_4e3m = hkdfextract(psk, SALT_4e3m) in

    let KEYSTREAM_3A = edhoc_kdf(PRK_3e2m, 'eleven', TH_3, plaintext_length) in
    let K_3 = edhoc_kdf(PRK_4e3m, 'twelve', TH_3, key_length) in
    let IV_3 = edhoc_kdf(PRK_3e2m, 'thirteen', TH_3, iv_length) in

    let external_aad_3 = <ID_CRED_PSK, TH_3, CRED_I, CRED_R> in
    let ad_3 = <'Encrypt0','empty',external_aad_3> in
    let plaintext_3b = <~EAD_3> in
    let ciphertext_3b = aeadenc(plaintext_3b, K_3, IV_3, ad_3) in
    let plaintext_3a = <ID_CRED_PSK, ciphertext_3b> in
    let m3 = encxor(plaintext_3a, KEYSTREAM_3A) in

    let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_I, CRED_R>) in
    let K_4 = edhoc_kdf(PRK_4e3m,'eight', TH_4, key_length) in
    let IV_4 = edhoc_kdf(PRK_3e2m,'nine', TH_4, iv_length) in
    let PRK_out = edhoc_kdf(PRK_4e3m,'seven', TH_4, hash_length) in
    out(m3);
    event TransmitEAD(m3, ~EAD_3, PRK_4e3m);

    in(m4);
    let external_aad_4 = <TH_4> in
    let ad_4 = <'Encrypt0','empty',external_aad_4> in
    let plaintext_4 = aeaddec(m4, K_4, IV_4, ad_4) in
    let EAD_4 = plaintext_4 in

    event AcceptI(~cid, method_four, subject_i, subject_r, PRK_out, ~X, G_Y);
    event FinishI(~cid, PRK_out);
    0
  ) else (0)

/* -------------------- Responder -------------------- */
let R(~cid, ID_CRED_PSK) =
  in(<C_R,EAD_2,suitesR>);
  in(m1);
  let <method,suitesI,G_X,C_I,EAD_1> = m1 in

  event MethodOk(method);

  new ~Y;
  new ~EAD_4;
  event LeakShare(~Y);
  event CompromiseShare(~Y);
  event LeakEAD(~EAD_4);

  let CRED_I = get_cred_i(ID_CRED_PSK) in
  let CRED_R = get_cred_r(ID_CRED_PSK) in
  let psk    = get_psk(ID_CRED_PSK) in
  let subject_i = get_subject(CRED_I) in
  let subject_r = get_subject(CRED_R) in

  event Start_R(~cid, method, subject_r);

  let G_Y = 'g'^~Y in
  let G_XY = G_X^~Y in

  let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
  let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in
  let PRK_2e = hkdfextract(TH_2, G_XY) in

  if method = method_four() then (
    let plaintext_2 = <C_R, EAD_2> in
    let KEYSTREAM_2A = edhoc_kdf(PRK_2e,'tzero', TH_2, plaintext_length) in
    event THRShared(TH_2);
    event DerivedRShared(G_XY);

    let m2 = <G_Y, encxor(plaintext_2, KEYSTREAM_2A)> in
    out(m2);

    in(m3);
    let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
    let PRK_3e2m = PRK_2e in
    let SALT_4e3m = edhoc_kdf(PRK_3e2m,'five', TH_3, hash_length) in
    let PRK_4e3m = hkdfextract(psk, SALT_4e3m) in
    let KEYSTREAM_3 = edhoc_kdf(PRK_3e2m,'eleven', TH_3, plaintext_length) in
    let K_3 = edhoc_kdf(PRK_4e3m,'twelve', TH_3, key_length) in
    let IV_3 = edhoc_kdf(PRK_3e2m,'thirteen', TH_3, iv_length) in
    let plaintext_3a = decxor(m3, KEYSTREAM_3) in
    let <ID_CRED_PSK_in, ciphertext_3b> = plaintext_3a in

    if ID_CRED_PSK_in = ID_CRED_PSK then (
      let external_aad_3 = <ID_CRED_PSK, TH_3, CRED_I, CRED_R> in
      let ad_3 = <'Encrypt0','empty',external_aad_3> in
      let plaintext_3b = aeaddec(ciphertext_3b, K_3, IV_3, ad_3) in
      let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_I, CRED_R>) in
      let K_4 = edhoc_kdf(PRK_4e3m,'eight', TH_4, key_length) in
      let IV_4 = edhoc_kdf(PRK_3e2m,'nine', TH_4, iv_length) in
      let PRK_out = edhoc_kdf(PRK_4e3m,'seven', TH_4, hash_length) in
      let external_aad_4 = <TH_4> in
      let ad_4 = <'Encrypt0','empty',external_aad_4> in
      let m4 = aeadenc(~EAD_4, K_4, IV_4, ad_4) in
      out(m4);

      event TransmitEAD(m4, ~EAD_4, PRK_out);
      event AcceptR(~cid, method_four, subject_i, subject_r, PRK_out, G_X, ~Y);
      event FinishR(~cid, PRK_out);
      event LeakSessionKey(PRK_out);
      0
    ) else (0)
  ) else (0)

/* -------------------- Main Process -------------------- */
let compromise(psk) =
  in('Comp'); event Compromise(psk); out(psk)

process:
  new ~psk;
  event Honest(~psk);

  !(
    new ~cid;
    new ~subject_i;
    new ~subject_r;

    let cred_i = make_cred(~subject_i, ~psk) in
    let cred_r = make_cred(~subject_r, ~psk) in
    let ID_CRED_PSK = make_id(cred_i, cred_r, ~psk) in

    event ExposeSubjectI(~subject_i);
    event ExposeSubjectR(~subject_r);

    I(~cid, method_four(), ID_CRED_PSK)
    | R(~cid, ID_CRED_PSK)
    | compromise(~psk)
  )


restriction OnlyMethodFour:
  "All method #i. MethodOk(method) @i ==> method = method_four()"

// ******************************************************************
// ************** Reachability   ************************************
// ******************************************************************

/* there exists at least one initiator AcceptI */
lemma exists_acceptI:
  exists-trace
  "Ex cid m prk x gy subjI subjR #t.
    AcceptI(cid, m, subjI, subjR, prk, x, gy) @ t"

/* there exists at least one responder AcceptR */
lemma exists_acceptR:
  exists-trace
  "Ex cid m prk gx y subjI subjR #t.
    AcceptR(cid, m, subjI, subjR, prk, gx, y) @ t"

/* there exist two AcceptI events (may be same cid, but proves two accepts reachable) */
lemma two_acceptI:
  exists-trace
  "Ex cid1 cid2 m prk1 prk2 x1 x2 gy1 gy2 subjI subjR #t1 #t2.
    AcceptI(cid1, m, subjI, subjR, prk1, x1, gy1) @ t1
    & AcceptI(cid2, m, subjI, subjR, prk2, x2, gy2) @ t2"

/* there exist two distinct AcceptI */
lemma two_distinct_acceptI:
    exists-trace
    "Ex cid1 cid2 m prk1 prk2 x1 x2 gy1 gy2 subjI1 subjI2 subjR1 subjR2 #t1 #t2.
     AcceptI(cid1, m, subjI1, subjR1, prk1, x1, gy1) @ t1
     & AcceptI(cid2, m, subjI2, subjR2, prk2, x2, gy2) @ t2
     & not(cid1 = cid2)"

/* same for responders */
lemma two_distinct_acceptR:
  exists-trace
  "Ex cid1 cid2 m prk1 prk2 gx1 gx2 y1 y2 subjI1 subjI2 subjR1 subjR2 #t1 #t2.
    AcceptR(cid1, m, subjI1, subjR1, prk1, gx1, y1) @ t1
    & AcceptR(cid2, m, subjI2, subjR2, prk2, gx2, y2) @ t2
    & not(cid1 = cid2)"

// /* uniqueness (injectivity) of AcceptI: any two accepts must have same cid */
// lemma unique_AcceptI:
//   "All cid1 cid2 m prk1 prk2 x1 x2 gy1 gy2 subjI subjR #t1 #t2.
//      (AcceptI(cid1, m, subjI, subjR, prk1, x1, gy1) @ t1
//       & AcceptI(cid2, m, subjI, subjR, prk2, x2, gy2) @ t2) ==> cid1 = cid2"

// /* uniqueness for AcceptR */
// lemma unique_AcceptR:
//   "All cid1 cid2 m prk1 prk2 gx1 gx2 y1 y2 subjI subjR #t1 #t2.
//      (AcceptR(cid1, m, subjI, subjR, prk1, gx1, y1) @ t1
//       & AcceptR(cid2, m, subjI, subjR, prk2, gx2, y2) @ t2) ==> cid1 = cid2"


end