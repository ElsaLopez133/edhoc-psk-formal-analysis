
// ******************************************************************
// ************** Reachability   ************************************
// ******************************************************************

#ifdef SanityChecks

/* there exists at least one initiator AcceptI */
lemma exists_acceptI[output=[proverif]]:
  exists-trace
  "Ex cid m idI prk x gy credI credR psk #t.
    AcceptI(cid, idI, m, credR, credR, prk, x, gy, psk) @ t"

/* there exists at least one responder AcceptR */
lemma exists_acceptR[output=[proverif]]:
  exists-trace
  "Ex cid idR m prk gx y credI credR psk #t.
    AcceptR(cid, idR, m, credI, credR, prk, gx, y, psk) @ t"

#endif

// ******************************************************************
// ************** Confidentiality  **********************************
// ******************************************************************

// This first two lemmas prove secrecy from the point of view of ONE of the peers
// In this case, there is no need of leaking the DH shares, since the attacker 
// can impersonate one of the peers from the beginning if both PSK and identites
// are leaked.
lemma secretR_psk:
  "All cid m credI credR prk gx y psk #i #j #k #l.
    AcceptR(cid, m, credI, credR, prk, gx, y, psk)@i & K(prk)@j & Honest(psk)@k
    & HonestSubject(credI)@l
   ==> 
    (Ex #t. Compromise(psk)@t & t < j)
    | 
    (Ex #t. LeakSessionKey(prk)@t)
    "

lemma secretI_psk:
  "All cid m credI credR prk x gy psk #i #j #k #l.
     AcceptI(cid, m, credI, credR, prk, x, gy, psk)@i & K(prk)@j & Honest(psk)@k
     & HonestSubject(credR)@l
   ==> 
    (Ex #t. Compromise(psk)@t)
    | 
    (Ex #t. LeakSessionKey(prk)@t)
    "

// In this case, the attacker needs to know one of the private DH values 
// in order to derive the session key.
// This is because we are now requiring that both peers derive the key
lemma secret_psk:
  "All cid1 cid2 m credI credR prk x gy y gx psk #i #j #k #p. // #l #c.
     AcceptI(cid1, m, credI, credR, prk, x, gy, psk)@i & 
     AcceptR(cid2, m, credI, credR, prk, gx, y, psk)@j &
     K(prk)@k & Honest(psk)@p
   ==> 
   (Ex #t #c. Compromise(psk)@t & t < k & LeakShare(x)@c)
   |
   (Ex #t #c. Compromise(psk)@t & t < k & LeakShare(y)@c)
    | 
   (Ex #t. LeakSessionKey(prk)@t)
    "

// ******************************************************************
// ****Full Agreement: Authentication and key confirmation***********
// ******************************************************************

// Authentication of the Initiator to the Responder
// If a Responder accepted a session, i.e., it finished, then there must 
// be a Initiator that derived the same values (same prk), 
// unless PSK and subjects were leaked, in which case the attacker can forge
// a session as an Initiator

// This lemma proves uniqueness and mutual authentication. So, if there are two sessions
// of R, with the same prk and psk, then they must be the same session AND and Initiator must
// have enageged in a session, unless the PSK or subjects were leaked
// If this happens, then the attacker could play the role of I and there would not
// be an Initiator running in the session.
lemma full_agreement_RI:
  "All cid1 cid2 m credI1 credI2 credR1 credR2 prk gx1 gx2 y1 y2 psk #i #j #k #l #c.
     AcceptR(cid1, m, credI1, credR1, prk, gx1, y1, psk)@i
     & AcceptR(cid2, m, credI2, credR2, prk, gx2, y2, psk)@j
     & Honest(psk)@k & HonestSubject(credI1)@l & HonestSubject(credI2)@c
   ==> (Ex cid credI credR x gy prk #t.
          DerivedI(cid, m, credI, credR, prk, x, gy, psk)@t & t < i & t < j 
          & cid1 = cid2 & gx1 = gx2 & y1 = y2 & credI1 = credI2 & credR1 = credR2 
          & credI = credI1 & credR = credR1 & #i = #j)
    | 
    (Ex #t. Compromise(psk)@t & t < j)
    "     

// Authentication of the Responder to the Initiator
// If an Initiator accepted a session, i.e., it finished, then there must 
// be a Responder that has already completed the protocol with the same prk, 
// unless PSK and subjects were leaked, in which case the attacker can forge
// a session as a Repsonder

lemma full_agreement_IR:
  "All cid1 cid2 m credI1 credI2 credR1 credR2 prk x1 x2 gy1 gy2 psk #i #j #k #l #c.
     AcceptI(cid1, m, credI1, credR1, prk, x1, gy1, psk)@i
     & AcceptI(cid2, m, credI2, credR2, prk, x2, gy2, psk)@j
     & Honest(psk)@k &HonestSubject(credR1)@l & HonestSubject(credR2)@c
   ==> (Ex cid credI credR gx y prk #t.
          AcceptR(cid, m, credI, credR, prk, gx, y, psk)@t & t < i & t < j 
          & cid1 = cid2 & x1 = x2 & gy1 = gy2 & credI1 = credI2 & credR1 = credR2 
          & credI = credI1 & credR = credR1 & #i = #j)
    | 
    (Ex #t. Compromise(psk)@t & t < j)
    "   

// *************************************************************
// ********************** Perfect Forward Secrecy **************
// *************************************************************

lemma pfs:
  "All cid1 cid2 m credI credR prk psk gy x gx y #i #j #c #k #l #p #u.
     AcceptI(cid1, m, credI, credR, prk, x, gy, psk)@i
     & AcceptR(cid2, m, credI, credR, prk, gx, y, psk)@j
     & Compromise(psk)@c  & i < c // long-term key is compromised after session
     & Honest(psk)@k
     &HonestSubject(credI)@p & HonestSubject(credR)@u
     & K(prk)@l
     ==>
     (Ex #t. LeakSessionKey(prk)@t & t < l)
     | 
     (Ex #t. LeakShare(x)@t & t < l )
     |
     (Ex #t. LeakShare(y)@t & t < l )
  "

// ******************************************************************
// ************** Attacker capabilities *****************************
// ******************************************************************

// lemma AttackerGetsAnyDHShare:
//   "Ex X #i. (LeakShare(X)@i)"

// lemma AttackerGetsSessionKey:
//   "Ex key #i. LeakSessionKey(key)@i"

// lemma AttackerGetsPSK:
//   "Ex psk #i. Compromise(psk)@i"
