
// ******************************************************************
// ************** Reachability   ************************************
// ******************************************************************

// PASSED

#ifdef SanityChecks

/* there exists at least one initiator AcceptI */
lemma exists_acceptI[output=[proverif]]:
  exists-trace
  "Ex cid m prk x gy subjI subjR #t.
    AcceptI(cid, m, subjI, subjR, prk, x, gy) @ t"

/* there exists at least one responder AcceptR */
lemma exists_acceptR[output=[proverif]]:
  exists-trace
  "Ex cid m prk gx y subjI subjR #t.
    AcceptR(cid, m, subjI, subjR, prk, gx, y) @ t"

#endif

// ******************************************************************
// ************** Confidentiality  **********************************
// ******************************************************************

// PASSED 

lemma secretR_psk:
  "All cid m subj_i subj_r prk gx y psk #i #j #k.
     AcceptR(cid, m, subj_i, subj_r, prk, gx, y)@i & K(prk)@j & Honest(psk)@k
   ==> (Ex #t. Compromise(psk)@t & t < i)
    | (Ex #t. LeakSessionKey(prk)@t)
    | (Ex #t. LeakShare(y)@t)
    | (Ex #t. LeakShare(gx)@t)"

lemma secretI_psk:
  "All cid m subj_i subj_r prk x gy psk #i #j #k.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i & K(prk)@j & Honest(psk)@k
   ==> (Ex #t. Compromise(psk)@t & t < i)
    | (Ex #t. LeakSessionKey(prk)@t)
    | (Ex #t. LeakShare(gy)@t)
    | (Ex #t. LeakShare(x)@t)"


// ******************************************************************
// ************** Authentication  ***********************************
// ******************************************************************

// PASSED

lemma honestauthRI_psk_non_inj:
  "All cid m subj_i subj_r prk gx y psk #i #k.
     AcceptR(cid, m, subj_i, subj_r, prk, gx, y)@i & Honest(psk)@k
   ==> (Ex cid2 prk2 x2 gy2 #t.
          DerivedI(cid2,m, subj_i, subj_r, prk2, x2, gy2)@t & t < i & prk = prk2)   // honest case
    | (Ex #t. Compromise(psk)@t & t < i)                                          // psk compromised
    | (Ex #t. LeakShare(y)@t)"                

lemma honestauthIR_psk_non_inj:
  "All cid m subj_i subj_r prk x gy psk #i #k.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i & Honest(psk)@k
   ==> (Ex cid2 prk2 gx2 y2 #j.
          AcceptR(cid2, m, subj_i, subj_r, prk2, gx2, y2)@j & j < i & prk = prk2)  // honest case
    | (Ex #t. Compromise(psk)@t & t < i)                                          // psk compromised
    | (Ex #t. LeakShare(x)@t)"       

// injectivity 
lemma authRI_psk_unique:
  "All cid1 cid2 m subj_i subj_r prk gx1 gx2 y1 y2 psk #i #j #k.
     AcceptR(cid1, m, subj_i, subj_r, prk, gx1, y1)@i &
     AcceptR(cid2, m, subj_i, subj_r, prk, gx2, y2)@j & Honest(psk)@k
   ==> (Ex #t. Compromise(psk)@t)
    | (Ex #t. Honest(psk)@t &    #i = #j)" // hack, dumb honest event added due to restrictions on exportable lemmas to proverif

lemma authIR_psk_unique:
  "All cid1 cid2 m subj_i subj_r prk x1 x2 gy1 gy2 psk #i #j #k.
     AcceptI(cid1, m, subj_i, subj_r, prk, x1, gy1)@i &
     AcceptI(cid2, m, subj_i, subj_r, prk, x2, gy2)@j & Honest(psk)@k
   ==> (Ex #t. Compromise(psk)@t)
    | (Ex #t. Honest(psk)@t &    #i = #j)" // hack, dumb honest event added due to restrictions on exportable lemmas to proverif


lemma data_authentication_I_to_R: 
    "All method subject_i subjetc_r x gy psk TH_2 TH_3 TH_4 suitesI EAD_1 EAD_2 EAD_3 m1 p2 p3 p4 #i #j PRK_out.
     AcceptIData(PRK_out,method,subject_i, subjetc_r,psk,x,gy,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, EAD_3, m1, p2, p3, p4>)@i
     & Honest(psk)@j ==>    
      (Ex #l y gx. l<i & AcceptRData(PRK_out,method,subject_i, subjetc_r,psk,y,gx,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, EAD_3, m1, p2, p3>)@l)
    | (Ex #l. l<i & Compromise(psk)@l)
    |  (Ex #l.  LeakShare(x)@l)      
       "


lemma data_authentication_R_to_I: 
    "All method subject_i subjetc_r y gx psk TH_2 TH_3 TH_4 suitesI EAD_1 EAD_2 EAD_3 m1 p2 p3 #i #j PRK_out.
     AcceptRData(PRK_out,method,subject_i, subjetc_r,psk,y,gx,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, EAD_3, m1, p2, p3>)@i
     & Honest(psk)@j ==>    
      (Ex #l x gy. l<i & SendIData(PRK_out,method,subject_i, subjetc_r,psk,x,gy,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, EAD_3, m1, p2, p3>)@l)
    | (Ex #l. l<i & Compromise(psk)@l)
    | (Ex #l.  LeakShare(y)@l)
       "

// ******************************************************************
// ************** Key Agreement  ************************************
// ******************************************************************

lemma key_agreement_R_implies_I:
 "All cid method subj_i subj_r PRK_out gx y #j.
    AcceptR(cid, method, subj_i, subj_r, PRK_out, gx, y)@j
  ==> 
     (Ex #i x gy. i<j & DerivedI(cid, method, subj_i, subj_r, PRK_out, x, gy)@i)
  | (Ex #k psk. Compromise(psk)@k)
  | (Ex #k. LeakShare(y)@k)
"

lemma key_agreement_I_implies_R:
 "All cid method subj_i subj_r PRK_out x gy #i.
    AcceptI(cid, method, subj_i, subj_r, PRK_out, x, gy)@i
  ==>
     (Ex #j gx y. j<i & AcceptR(cid, method, subj_i, subj_r, PRK_out, gx, y)@j)
  | (Ex #k psk. Compromise(psk)@k)
  | (Ex #k. LeakShare(x)@k)
"

// PASSED 

lemma pfs_psk:
  "All cid m subj_i subj_r prk x gy psk #i #j #k.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i & K(prk)@j & Honest(psk)@k
   ==> (Ex #t. LeakShare(x)@t & t < i)
    | (Ex #t. LeakShare(gy)@t & t < i)
    | (Ex #t. LeakSessionKey(prk)@t)
    | (Ex #t. Compromise(psk)@t)"

lemma explicit_key_confirmation_I:
  "All cid m subj_i subj_r prk x gy #i.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i
   ==> (Ex cid2 prk2 gx2 y2 #t.
          AcceptR(cid2, m, subj_i, subj_r, prk2, gx2, y2)@t & prk = prk2)
     | (Ex #t. LeakShare(x)@t)
     | (Ex #t psk. Compromise(psk)@t)"

// ******************************************************************
// ************** Identity binding***********************************
// ******************************************************************

// Whenever the initiator accepts with identities (subj_i, subj_r), 
// there must exist a corresponding eInitiateWithID(subj_i, subj_r) event earlier in the trace.
lemma identity_binding_I:
  "All cid m subj_i subj_r prk x gy #i.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i
   ==> (Ex #j. InitiateWithID(subj_i, subj_r)@j)"

lemma identity_binding_R:
  "All cid m subj_i subj_r prk gx y #i.
     AcceptR(cid, m, subj_i, subj_r, prk, gx, y)@i
   ==> (Ex #j. RespondWithID(subj_i, subj_r)@j)"

// We want to prove that the protocol gives identity against passive attackers
// Lemma: Secrecy of Responder's Identity
lemma secrecy_of_identity_R:
  "All subj_r #i. 
    (HonestSubjectR(subj_r) @i
    & not(Ex #k. ExposeSubjectR(subj_r) @k)) 
    ==> not(Ex #j. K(subj_r) @j)"

lemma secrecy_of_identity_I:
  "All subj_i #i. 
     (HonestSubjectI(subj_i) @i 
      & not(Ex #k. ExposeSubjectI(subj_i) @k))
    ==> not(Ex #j. K(subj_i) @j)"

// ******************************************************************
// ************** Distinctness (concurrent sessions) **************
// ******************************************************************

// lemma two_acceptI:
//   "Ex cid1 cid2 m prk1 prk2 x1 x2 gy1 gy2 subjI subjR #t1 #t2.
//      AcceptI(cid1, m, subjI, subjR, prk1, x1, gy1)@t1 &
//      AcceptI(cid2, m, subjI, subjR, prk2, x2, gy2)@t2"

// lemma two_distinct_acceptI:
//   "Ex cid1 cid2 m prk1 prk2 x1 x2 gy1 gy2 subjI subjR #t1 #t2.
//      AcceptI(cid1, m, subjI, subjR, prk1, x1, gy1)@t1 &
//      AcceptI(cid2, m, subjI, subjR, prk2, x2, gy2)@t2 &
//      not(cid1 = cid2)"

// lemma two_distinct_acceptR:
//   "Ex cid1 cid2 m prk1 prk2 gx1 gx2 y1 y2 subjI subjR #t1 #t2.
//      AcceptR(cid1, m, subjI, subjR, prk1, gx1, y1)@t1 &
//      AcceptR(cid2, m, subjI, subjR, prk2, gx2, y2)@t2 &
//      not(cid1 = cid2)"


// ******************************************************************
// ************** Attacker capabilities *****************************
// ******************************************************************

// lemma AttackerGetsAnyDHShare:
//   "Ex X #i. (LeakShare(X)@i)"

// lemma AttackerGetsSessionKey:
//   "Ex key #i. LeakSessionKey(key)@i"

// lemma AttackerGetsPSK:
//   "Ex psk #i. Compromise(psk)@i"

// ****************************************************************
// ************** Helper Lemmas ***********************************
// ****************************************************************

// The following lemmas do not cover any explicit security property from the draft, but help the provers

#ifdef  LeakShare
// the share are not secret in this scenario
#else

lemma secretShares[reuse]: //secrecy of the key
   "All k #i #j. Share(k)@i & KU(k)@j // the ephemeral, secret DH share cannot be known to the attacker
    ==> F"

lemma secretSharesPSK[reuse]: //secrecy of the key
   "All k #i #j. SharePSK(k)@i & KU(k)@j   // if a longterm DH share is known to the attacker
    ==>  (Ex #t. Compromise(k)@t)"             // it must have been leaked explicitly
    // | (Ex #t. LeakShare(k)@t)"

#endif

  
// ******************************************************************
// ************** Impersonation   ***********************************
// ******************************************************************

// Whenever I accept a session, it must be the case that the PSK was honest. 
// Therefore, no one without the PSK (i.e., a passive attacker) could have 
// impersonated my peer.
lemma no_passive_impersonation_I:
  "All cid m subj_i subj_r prk x gy #i.
     AcceptI(cid, m, subj_i, subj_r, prk, x, gy)@i
   ==> (Ex #j psk. Honest(psk)@j)"

lemma no_passive_impersonation_R:
  "All cid m subj_i subj_r prk y gx #i.
     AcceptR(cid, m, subj_i, subj_r, prk, y, gx)@i
   ==> (Ex #j psk. Honest(psk)@j)"
