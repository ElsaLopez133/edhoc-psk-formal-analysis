/*
 * Protocol:   EDHOC-PSK
   https://datatracker.ietf.org/doc/draft-ietf-lake-edhoc-psk/

   A lightweight DH-based key exchange, authenticated using Pre-Shared Keys
*/

theory edhoc_psk

begin

builtins: diffie-hellman, hashing, xor

functions: method_four/0, length/0,
           hash_length/0, key_length/0, iv_length/0, plaintext_length/0, aead_length/0,
           error_code_one/0, error_code_two/0,
           suitesIConst/0, suitesRConst/0,
           edhoc_kdf/3,
           aeadenc/4, aeaddec/4 [destructor],
           make_id/1,
           wrap/1,
           hash/1, hkdfextract/2, hkdfexpand/2,
           // Helper functions for tuple destructuring
           get_first/1, get_second/1, get_third/1, get_fourth/1, get_fifth/1

equations: aeaddec(aeadenc(m,r,k,ad),r,k,ad) = m,
           get_first(<a,b,c,d,e>) = a,
           get_second(<a,b,c,d,e>) = b,
           get_third(<a,b,c,d,e>) = c,
           get_fourth(<a,b,c,d,e>) = d,
           get_fifth(<a,b,c,d,e>) = e

// Setup rules for generating fresh values
rule DriverI:
  let method = method_four in
  [ Fr(~C_I), Fr(~EAD_1), Fr(~suitesI) ]
  -->
  [ InitiatorParams(method, ~suitesI, ~C_I, ~EAD_1) ]

rule DriverR:
  [ Fr(~C_R), Fr(~EAD_2), Fr(~suitesR) ]
  -->
  [ ResponderParams(~C_R, ~EAD_2, ~suitesR) ]

rule HonestPSK:
  [ Fr(~psk) ]
  -->
  [ !Honest(~psk), !PSK(~psk) ]

// INITIATOR RULES

rule I_1_SendMessage1:
  let 
    G_X = 'g'^~X
    m1 = <method, suitesI, G_X, C_I, EAD_1>
  in
  [
    InitiatorParams(method, suitesI, C_I, EAD_1),
    Fr(~X),
    Fr(~EAD_3),
    Fr(~cid),
    !PSK(psk)
  ]
  --[ 
    MethodOk(method),
    Start_I(~cid, method, psk)
  ]->
  [
    St_I_1(~cid, method, suitesI, C_I, EAD_1, ~X, G_X, ~EAD_3, psk),
    Out(m1)
  ]

rule I_2_ReceiveMessage2:
  let
    TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>)
    TH_2 = hash(<wrap(G_Y), wrap(TH_1)>)
    G_YX = G_Y^X
    PRK_2e = hkdfextract(G_YX, TH_2)
    KEYSTREAM_2 = edhoc_kdf(PRK_2e, <'azero', TH_2, plaintext_length>, plaintext_length)
    plaintext_2 = CIPHERTEXT_2 XOR KEYSTREAM_2
  in
  [
    St_I_1(cid, method, suitesI, C_I, EAD_1, X, G_X, EAD_3, psk),
    In(<G_Y, CIPHERTEXT_2>)
  ]
  -->
  [
    St_I_2(cid, method, suitesI, C_I, EAD_1, X, G_X, EAD_3, psk, G_Y, TH_2, PRK_2e, plaintext_2)
  ]

rule I_3_SendMessage3:
  let
    CRED_PSK = psk
    ID_CRED_PSK = make_id(CRED_PSK)
    PRK_3e2m = PRK_2e
    TH_3 = hash(<wrap(TH_2), plaintext_2, CRED_PSK>)
    SALT_4e3m = edhoc_kdf(PRK_3e2m, <'five', TH_3, hash_length>, hash_length)
    PRK_4e3m = hkdfextract(CRED_PSK, SALT_4e3m)
    KEYSTREAM_3 = edhoc_kdf(PRK_3e2m, <'eleven', TH_3, plaintext_length>, plaintext_length)
    K_3 = edhoc_kdf(PRK_4e3m, <'twelve', TH_3>, key_length)
    IV_3 = edhoc_kdf(PRK_3e2m, <'thirteen', TH_3>, iv_length)
    plaintext_3b = <'empty', ID_CRED_PSK, TH_3, CRED_PSK, EAD_3>
    ad_3 = <aead_length, 'empty', TH_3>
    ciphertext_3b = aeadenc(plaintext_3b, K_3, IV_3, ad_3)
    plaintext_3a = <ID_CRED_PSK, ciphertext_3b>
    m3 = plaintext_3a XOR KEYSTREAM_3
  in
  [
    St_I_2(cid, method, suitesI, C_I, EAD_1, X, G_X, EAD_3, psk, G_Y, TH_2, PRK_2e, plaintext_2)
  ]
  --[ Eq(method, method_four) ]->
  [
    St_I_3(cid, method, X, G_X, G_Y, EAD_3, psk, TH_3, PRK_4e3m, PRK_3e2m, ID_CRED_PSK, plaintext_3b),
    Out(m3)
  ]

rule I_4_ReceiveMessage4:
  let
    CRED_PSK = psk
    TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_PSK>)
    K_4 = edhoc_kdf(PRK_4e3m, <'eight', TH_4>, key_length)
    IV_4 = edhoc_kdf(PRK_3e2m, <'nine', TH_4>, iv_length)
    ad_4 = <aead_length, 'empty', TH_4>
    plaintext_4 = aeaddec(m4, K_4, IV_4, ad_4)
    EAD_4 = plaintext_4
    PRK_out = edhoc_kdf(PRK_4e3m, <'seven', TH_4>, hash_length)
  in
  [
    St_I_3(cid, method, X, G_X, G_Y, EAD_3, psk, TH_3, PRK_4e3m, PRK_3e2m, ID_CRED_PSK, plaintext_3b),
    In(m4)
  ]
  --[ 
    AcceptI(cid, method_four, CRED_PSK, PRK_out, G_X, G_Y),
    FinishI(cid, PRK_out)
  ]->
  [
    St_I_Final(cid, PRK_out)
  ]

// RESPONDER RULES

rule R_1_ReceiveMessage1:
  let
    TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>)
  in
  [
    ResponderParams(C_R, EAD_2, suitesR),
    Fr(~Y),
    Fr(~EAD_4),
    Fr(~cid),
    !PSK(psk),
    In(<method, suitesI, G_X, C_I, EAD_1>)
  ]
  --[
    Start_R(~cid, method, psk),
    MethodOk(method)
  ]->
  [
    St_R_1(~cid, method, suitesI, C_I, EAD_1, C_R, EAD_2, suitesR, ~Y, G_X, TH_1, ~EAD_4, psk)
  ]

rule R_2_SendMessage2:
  let
    G_Y = 'g'^Y
    TH_2 = hash(<wrap(G_Y), wrap(TH_1)>)
    G_XY = G_X^Y
    PRK_2e = hkdfextract(G_XY, TH_2)
    KEYSTREAM_2 = edhoc_kdf(PRK_2e, <'azero', TH_2, plaintext_length>, plaintext_length)
    plaintext_2 = <C_R, EAD_2>
    CIPHERTEXT_2 = plaintext_2 XOR KEYSTREAM_2
    m2 = <G_Y, CIPHERTEXT_2>
  in
  [
    St_R_1(cid, method, suitesI, C_I, EAD_1, C_R, EAD_2, suitesR, Y, G_X, TH_1, EAD_4, psk)
  ]
  -->
  [
    St_R_2(cid, method, suitesI, C_I, EAD_1, C_R, EAD_2, Y, G_Y, G_X, TH_2, PRK_2e, EAD_4, psk),
    Out(m2)
  ]

rule R_3_ReceiveMessage3:
  let
    CRED_PSK = psk
    ID_CRED_PSK = make_id(CRED_PSK)
    PRK_3e2m = PRK_2e
    TH_3 = hash(<wrap(TH_2), <C_R, EAD_2>, CRED_PSK>)
    KEYSTREAM_3 = edhoc_kdf(PRK_3e2m, <'eleven', TH_3, plaintext_length>, plaintext_length)
    plaintext_3a = m3 XOR KEYSTREAM_3
    SALT_4e3m = edhoc_kdf(PRK_3e2m, <'five', TH_3, hash_length>, hash_length)
    PRK_4e3m = hkdfextract(CRED_PSK, SALT_4e3m)
    K_3 = edhoc_kdf(PRK_4e3m, <'twelve', TH_3>, key_length)
    IV_3 = edhoc_kdf(PRK_3e2m, <'thirteen', TH_3>, iv_length)
    ad_3 = <aead_length, 'empty', TH_3>
  in
  [
    St_R_2(cid, method, suitesI, C_I, EAD_1, C_R, EAD_2, Y, G_Y, G_X, TH_2, PRK_2e, EAD_4, psk),
    In(m3)
  ]
  --[ Eq(method, method_four) ]->
  [
    St_R_3(cid, method, C_R, EAD_2, Y, G_Y, G_X, TH_3, PRK_4e3m, PRK_3e2m, EAD_4, psk, plaintext_3a, K_3, IV_3, ad_3)
  ]

rule R_4_SendMessage4:
  let
    CRED_PSK = psk
    ID_CRED_PSK = make_id(CRED_PSK)
    // Decrypt and verify message 3
    ID_CRED_PSK_recv = fst(plaintext_3a)
    ciphertext_3b = snd(plaintext_3a)
    plaintext_3b = aeaddec(ciphertext_3b, K_3, IV_3, ad_3)
    // Extract components from plaintext_3b tuple
    empty_field = get_first(plaintext_3b)
    ID_CRED_PSK_check = get_second(plaintext_3b)
    TH_3_check = get_third(plaintext_3b)
    CRED_PSK_check = get_fourth(plaintext_3b)
    EAD_3 = get_fifth(plaintext_3b)
    
    // Compute message 4
    TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_PSK>)
    K_4 = edhoc_kdf(PRK_4e3m, <'eight', TH_4>, key_length)
    IV_4 = edhoc_kdf(PRK_3e2m, <'nine', TH_4>, iv_length)
    ad_4 = <aead_length, 'empty', TH_4>
    plaintext_4 = EAD_4
    m4 = aeadenc(plaintext_4, K_4, IV_4, ad_4)
    PRK_out = edhoc_kdf(PRK_4e3m, <'seven', TH_4>, hash_length)
  in
  [
    St_R_3(cid, method, C_R, EAD_2, Y, G_Y, G_X, TH_3, PRK_4e3m, PRK_3e2m, EAD_4, psk, plaintext_3a, K_3, IV_3, ad_3)
  ]
  --[
    Eq(ID_CRED_PSK_recv, ID_CRED_PSK),
    Eq(ID_CRED_PSK_check, ID_CRED_PSK),
    Eq(TH_3_check, TH_3),
    Eq(CRED_PSK_check, CRED_PSK),
    AcceptR(cid, method_four, CRED_PSK, PRK_out, G_X, G_Y),
    FinishR(cid, PRK_out)
  ]->
  [
    St_R_Final(cid, PRK_out),
    Out(m4)
  ]

// RESTRICTIONS
restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

restriction OnlyMethodFour:
  "All method #i. MethodOk(method) @i ==> method = method_four"

#include "LakePropertiesPSKTamarin.splib"

end