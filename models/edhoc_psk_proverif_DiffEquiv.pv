const g:bitstring.
free att:channel.
free sComp:bitstring.
free sEncrypt0:bitstring.
free seight:bitstring.
free seleven:bitstring.
free sempty:bitstring.
free sfive:bitstring.
free snine:bitstring.
free snull:bitstring.
free sseven:bitstring.
free sthirteen:bitstring.
free stwelve:bitstring.
free stzero:bitstring.
fun aead_length():bitstring.
fun aeadenc(bitstring,bitstring,bitstring,bitstring):bitstring.
fun const_grp():bitstring.
fun edhoc_kdf(bitstring,bitstring,bitstring,bitstring):bitstring.
fun encxor(bitstring,bitstring):bitstring.
fun exp(bitstring,bitstring):bitstring.
fun fst(bitstring):bitstring.
fun h(bitstring):bitstring.
fun hash(bitstring):bitstring.
fun hash_length():bitstring.
fun hkdfexpand(bitstring,bitstring):bitstring.
fun hkdfextract(bitstring,bitstring):bitstring.
fun iv_length():bitstring.
fun key_length():bitstring.
fun length():bitstring.
fun make_cred(bitstring,bitstring):bitstring.
fun make_id(bitstring,bitstring,bitstring):bitstring.
fun method_four():bitstring.
fun pair(bitstring,bitstring):bitstring.
fun plaintext_length():bitstring.
fun snd(bitstring):bitstring.
fun wrap(bitstring):bitstring.
fun xor(bitstring,bitstring):bitstring.
fun zero():bitstring.
event eAcceptI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptIData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptRData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eCompromise(bitstring).
event eDerivedI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eDerivedIShared(bitstring).
event eDerivedR(bitstring,bitstring,bitstring,bitstring).
event eDerivedRShared(bitstring).
event eExposeSubjectI(bitstring).
event eExposeSubjectR(bitstring).
event eFinishI(bitstring,bitstring).
event eFinishR(bitstring,bitstring).
event eHonest(bitstring).
event eHonestSubjectI(bitstring).
event eHonestSubjectR(bitstring).
event eInitiateWithID(bitstring,bitstring).
event eLeakEAD(bitstring).
event eLeakSessionKey(bitstring).
event eLeakShare(bitstring).
event eMethodOk(bitstring).
event eRespondWithID(bitstring,bitstring).
event eSendIData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSendRData(bitstring,bitstring,bitstring,bitstring,bitstring).
event eShare(bitstring).
event eSharePSK(bitstring).
event eStart_I(bitstring,bitstring,bitstring).
event eStart_R(bitstring,bitstring,bitstring).
event eTHRShared(bitstring).
event eTransmitEAD(bitstring,bitstring,bitstring).
equation forall a:bitstring,b:bitstring; exp( exp(g,a),b) = exp(exp(g,b),a).
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
reduc forall ad:bitstring, k:bitstring, m:bitstring, r:bitstring;   aeaddec(aeadenc(m, k, r, ad), k, r, ad) = m.
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_cred_i(make_id(cred_i, cred_r, psk)) = cred_i [private].
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_cred_r(make_id(cred_i, cred_r, psk)) = cred_r [private].
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_psk(make_id(cred_i, cred_r, psk)) = psk [private].
reduc forall k:bitstring, m:bitstring;   decxor(encxor(m, k), k) = m.
reduc forall psk:bitstring, subject:bitstring;   get_subject(make_cred(subject, psk)) = subject.
reduc forall x:bitstring;   check_grp(x) = const_grp.
axiom k:bitstring; event(eShare( k )) && attacker( k ) ==> event(eLeakShare(k)).
set preciseActions=true.
set simplifyProcess=false.
set reconstructTrace=false.
set attacker=passive.

let CompromiseShare(s_2:bitstring)=
    event eLeakShare( snull ).
let leakSKey(key_2:bitstring)=
    event eLeakSessionKey( snull ).
let I(cid_2:bitstring, method_2:bitstring, ID_CRED_PSK_2:bitstring)=
    in(att,(suitesI_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring)));
    event eMethodOk( method_2 );
    new X_2:bitstring;
    new EAD_3_2:bitstring;
    event eShare( X_2 );
    event eLeakEAD( EAD_3_2 );
    ((CompromiseShare(X_2))
   | (let CRED_I_2:bitstring=get_cred_i(ID_CRED_PSK_2) in
      let CRED_R_2:bitstring=get_cred_r(ID_CRED_PSK_2) in
      let psk_2:bitstring=get_psk(ID_CRED_PSK_2) in
      let subject_i_2:bitstring=get_subject(CRED_I_2) in
      let subject_r_2:bitstring=get_subject(CRED_R_2) in
      event eInitiateWithID( subject_i_2, subject_r_2 );
      event eStart_I( cid_2, method_2, subject_i_2 );
      let G_X_2:bitstring=exp(g, X_2) in
      let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
      out(att,m1_2);
      in(att,m2_2:bitstring);
      let (G_Y_2:bitstring, CIPHERTEXT_2_2:bitstring)=m2_2 in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let G_YX_2:bitstring=exp(G_Y_2, X_2) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_YX_2) in
      let KEYSTREAM_2A_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                             plaintext_length) in
      let plaintext_2_2:bitstring=decxor(CIPHERTEXT_2_2, KEYSTREAM_2A_2) in
      let (C_R_2:bitstring, EAD_2_2:bitstring)=plaintext_2_2 in
      let (=method_2)=method_four in 
          (let PRK_3e2m_2:bitstring=PRK_2e_2 in
           event eDerivedIShared( G_YX_2 );
           let TH_3_2:bitstring=hash((wrap(TH_2_2), plaintext_2_2)) in
           let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                               hash_length) in
           let PRK_4e3m_2:bitstring=hkdfextract(psk_2, SALT_4e3m_2) in
           let KEYSTREAM_3A_2:bitstring=edhoc_kdf(PRK_3e2m_2, seleven, TH_3_2,
                                                  plaintext_length) in
           let K_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, stwelve, TH_3_2, key_length) in
           let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthirteen, TH_3_2,
                                          iv_length) in
           let external_aad_3_2:bitstring=(ID_CRED_PSK_2, (TH_3_2, (CRED_I_2, CRED_R_2))) in
           let ad_3_2:bitstring=(sEncrypt0, (sempty, external_aad_3_2)) in
           let plaintext_3b_2:bitstring=EAD_3_2 in
           let ciphertext_3b_2:bitstring=aeadenc(plaintext_3b_2, K_3_2, IV_3_2,
                                                 ad_3_2) in
           let plaintext_3a_2:bitstring=(ID_CRED_PSK_2, ciphertext_3b_2) in
           let m3_2:bitstring=encxor(plaintext_3a_2, KEYSTREAM_3A_2) in
           let TH_4_2:bitstring=hash((wrap(TH_3_2), (ID_CRED_PSK_2, (plaintext_3b_2, (CRED_I_2, CRED_R_2))))) in
           let K_4_2:bitstring=edhoc_kdf(PRK_4e3m_2, seight, TH_4_2, key_length) in
           let IV_4_2:bitstring=edhoc_kdf(PRK_3e2m_2, snine, TH_4_2, iv_length) in
           let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                             hash_length) in
           event eDerivedI( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                            X_2, G_Y_2
                 );
           event eSendIData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                             X_2, G_Y_2,
                             (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3a_2)))))))))
                 );
           out(att,m3_2);
           event eTransmitEAD( m3_2, EAD_3_2, PRK_4e3m_2 );
           ((in(att,m4_2:bitstring);
             let external_aad_4_2:bitstring=TH_4_2 in
             let ad_4_2:bitstring=(sEncrypt0, (sempty, external_aad_4_2)) in
             let plaintext_4_2:bitstring=aeaddec(m4_2, K_4_2, IV_4_2, ad_4_2) in
             let EAD_4_2:bitstring=plaintext_4_2 in
             event eAcceptIData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                                 X_2, G_Y_2,
                                 (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, (plaintext_3a_2, plaintext_4_2))))))))))
                   );
             event eAcceptI( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                             X_2, G_Y_2, psk_2
                   );
             event eFinishI( cid_2, PRK_out_2 ))
          | (leakSKey(PRK_out_2)))))).
let R(cid_2:bitstring, ID_CRED_PSK_2:bitstring)=
    in(att,(C_R_2:bitstring, (EAD_2_2:bitstring, suitesR_2:bitstring)));
    in(att,m1_2:bitstring);
    let (method_2:bitstring, (suitesI_2:bitstring, (G_X_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring))))=m1_2 in
    event eMethodOk( method_2 );
    new Y_2:bitstring;
    new EAD_4_2:bitstring;
    event eShare( Y_2 );
    event eLeakEAD( EAD_4_2 );
    ((CompromiseShare(Y_2))
   | (let CRED_I_2:bitstring=get_cred_i(ID_CRED_PSK_2) in
      let CRED_R_2:bitstring=get_cred_r(ID_CRED_PSK_2) in
      let psk_2:bitstring=get_psk(ID_CRED_PSK_2) in
      let subject_i_2:bitstring=get_subject(CRED_I_2) in
      let subject_r_2:bitstring=get_subject(CRED_R_2) in
      event eRespondWithID( subject_i_2, subject_r_2 );
      event eStart_R( cid_2, method_2, subject_r_2 );
      let G_Y_2:bitstring=exp(g, Y_2) in
      let G_XY_2:bitstring=exp(G_X_2, Y_2) in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_XY_2) in
      let (=method_2)=method_four in 
          (let plaintext_2_2:bitstring=(C_R_2, EAD_2_2) in
           let KEYSTREAM_2A_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                                  plaintext_length) in
           event eTHRShared( TH_2_2 );
           event eDerivedRShared( G_XY_2 );
           let m2_2:bitstring=(G_Y_2, encxor(plaintext_2_2, KEYSTREAM_2A_2)) in
           event eSendRData( method_2, subject_i_2, subject_r_2, psk_2,
                             (TH_2_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (m1_2, plaintext_2_2)))))
                 );
           out(att,m2_2);
           in(att,m3_2:bitstring);
           let TH_3_2:bitstring=hash((wrap(TH_2_2), plaintext_2_2)) in
           let PRK_3e2m_2:bitstring=PRK_2e_2 in
           let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                               hash_length) in
           let PRK_4e3m_2:bitstring=hkdfextract(psk_2, SALT_4e3m_2) in
           let KEYSTREAM_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, seleven, TH_3_2,
                                                 plaintext_length) in
           let K_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, stwelve, TH_3_2, key_length) in
           let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthirteen, TH_3_2,
                                          iv_length) in
           let plaintext_3a_2:bitstring=decxor(m3_2, KEYSTREAM_3_2) in
           let (ID_CRED_PSK_in_2:bitstring, ciphertext_3b_2:bitstring)=plaintext_3a_2 in
           let (=ID_CRED_PSK_in_2)=ID_CRED_PSK_2 in 
               (let external_aad_3_2:bitstring=(ID_CRED_PSK_2, (TH_3_2, (CRED_I_2, CRED_R_2))) in
                let ad_3_2:bitstring=(sEncrypt0, (sempty, external_aad_3_2)) in
                let plaintext_3b_2:bitstring=aeaddec(ciphertext_3b_2, K_3_2, IV_3_2,
                                                     ad_3_2) in
                let EAD_3_2:bitstring=plaintext_3b_2 in
                let TH_4_2:bitstring=hash((wrap(TH_3_2), (ID_CRED_PSK_2, (plaintext_3b_2, (CRED_I_2, CRED_R_2))))) in
                let K_4_2:bitstring=edhoc_kdf(PRK_4e3m_2, seight, TH_4_2, key_length) in
                let IV_4_2:bitstring=edhoc_kdf(PRK_3e2m_2, snine, TH_4_2, iv_length) in
                let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                  hash_length) in
                let external_aad_4_2:bitstring=TH_4_2 in
                let ad_4_2:bitstring=(sEncrypt0, (sempty, external_aad_4_2)) in
                let m4_2:bitstring=aeadenc(EAD_4_2, K_4_2, IV_4_2, ad_4_2) in
                event eDerivedR( cid_2, PRK_out_2, Y_2, G_X_2 );
                event eTransmitEAD( m4_2, EAD_4_2, PRK_out_2 );
                event eAcceptR( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                                G_X_2, Y_2, psk_2
                      );
                event eAcceptRData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                                    Y_2, G_X_2,
                                    (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3a_2)))))))))
                      );
                event eFinishR( cid_2, PRK_out_2 );
                out(att,m4_2);
                ((0)
               | (leakSKey(PRK_out_2))))))).
let compromise(psk_2:bitstring)=
    in(att,=sComp);
    event eCompromise( psk_2 );
    event eSharePSK( psk_2 );
    out(att,psk_2).
let LeakSubjectI(subj_i_2:bitstring)=
    in(att,=sComp);
    event eExposeSubjectI( subj_i_2 );
    out(att,subj_i_2).
let LeakSubjectR(subj_r_2:bitstring)=
    in(att,=sComp);
    event eExposeSubjectR( subj_r_2 );
    out(att,subj_r_2).

process
    !
    (new psk_4:bitstring;
     event eHonest( psk_4 );
     new cid_2:bitstring;
     new subject_i_4:bitstring;
     new subject_r_4:bitstring;
     new subject_i2_2:bitstring;
     event eHonestSubjectI( subject_i_4 );
     event eHonestSubjectI( subject_i2_2 );
     event eHonestSubjectR( subject_r_4 );
     let cred_i_2:bitstring=make_cred(subject_i_4, psk_4) in
     let cred_i2_2:bitstring=make_cred(subject_i2_2, psk_4) in
     let cred_r_2:bitstring=make_cred(subject_r_4, psk_4) in
     let id_cred_psk_2:bitstring=make_id(cred_i_2, cred_r_2, psk_4) in
     let id_cred_psk2_2:bitstring=make_id(cred_i2_2, cred_r_2, psk_4) in
     !
     (((I(cid_2, method_four, choice[id_cred_psk_2, id_cred_psk2_2]))
     | (!
        (R(cid_2, id_cred_psk_2))))))

(*
WARNING: the following wellformedness checks failed!

Fact usage
==========

Possible reasons: 
1. Fact names are case-sensitive, different capitalizations are considered as different facts, i.e., Fact() is different from FAct(). Check the capitalization of your fact names.
2. Same fact is used with different arities, i.e., Fact('A','B') is different from Fact('A'). Check the arguments of your facts.
 
  
Fact `accepti':

  1. Lemma `no_passive_impersonation_I', capitalization  "AcceptI", 7, Linear
       Fact {factTag = ProtoFact Linear "AcceptI" 7, factAnnotations = fromList [], factTerms = [Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  2. Lemma `identity_binding_I', capitalization  "AcceptI", 8, Linear
       Fact {factTag = ProtoFact Linear "AcceptI" 8, factAnnotations = fromList [], factTerms = [Bound 8,Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  
Fact `acceptr':

  1. Lemma `no_passive_impersonation_R', capitalization  "AcceptR", 7, Linear
       Fact {factTag = ProtoFact Linear "AcceptR" 7, factAnnotations = fromList [], factTerms = [Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  2. Lemma `identity_binding_R', capitalization  "AcceptR", 8, Linear
       Fact {factTag = ProtoFact Linear "AcceptR" 8, factAnnotations = fromList [], factTerms = [Bound 8,Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}

Inexistant lemma actions
========================

  lemma `secretR_psk' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "DerivedI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "ExposeSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "SendIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "DerivedI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "InitiateWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "RespondWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_R' references action 
    fact "ExposeSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_R' references action 
    fact "HonestSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_I' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_I' references action 
    fact "HonestSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretShares' references action 
    fact "Share" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretSharesPSK' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretSharesPSK' references action 
    fact "SharePSK" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "AcceptI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "AcceptR" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `OnlyMethodFour' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

Formula terms
=============

  lemma `explicit_key_confirmation_I' uses terms of the wrong form:
    `Free psk'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)

(*
WARNING: the following wellformedness checks failed!

Fact usage
==========

Possible reasons: 
1. Fact names are case-sensitive, different capitalizations are considered as different facts, i.e., Fact() is different from FAct(). Check the capitalization of your fact names.
2. Same fact is used with different arities, i.e., Fact('A','B') is different from Fact('A'). Check the arguments of your facts.
 
  
Fact `accepti':

  1. Lemma `no_passive_impersonation_I', capitalization  "AcceptI", 7, Linear
       Fact {factTag = ProtoFact Linear "AcceptI" 7, factAnnotations = fromList [], factTerms = [Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  2. Lemma `identity_binding_I', capitalization  "AcceptI", 8, Linear
       Fact {factTag = ProtoFact Linear "AcceptI" 8, factAnnotations = fromList [], factTerms = [Bound 8,Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  
Fact `acceptr':

  1. Lemma `no_passive_impersonation_R', capitalization  "AcceptR", 7, Linear
       Fact {factTag = ProtoFact Linear "AcceptR" 7, factAnnotations = fromList [], factTerms = [Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}
  
  2. Lemma `identity_binding_R', capitalization  "AcceptR", 8, Linear
       Fact {factTag = ProtoFact Linear "AcceptR" 8, factAnnotations = fromList [], factTerms = [Bound 8,Bound 7,Bound 6,Bound 5,Bound 4,Bound 3,Bound 2,Bound 1]}

Inexistant lemma actions
========================

  lemma `secretR_psk' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "DerivedI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "ExposeSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authRI_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authIR_psk_unique' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "SendIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "DerivedI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `pfs_psk' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "InitiateWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "RespondWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_R' references action 
    fact "ExposeSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_R' references action 
    fact "HonestSubjectR" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_I' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secrecy_of_identity_I' references action 
    fact "HonestSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretShares' references action 
    fact "Share" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretSharesPSK' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretSharesPSK' references action 
    fact "SharePSK" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "AcceptI" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "AcceptR" (arity 7, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `OnlyMethodFour' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

Formula terms
=============

  lemma `explicit_key_confirmation_I' uses terms of the wrong form:
    `Free psk'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)
