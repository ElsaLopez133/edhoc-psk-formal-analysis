/*
 * Protocol:   EDHOC-PSK
 * Source:     draft-ietf-lake-edhoc-psk
 * Model:      Cleaned for PSK authentication (method_four), no MAC or signatures
*/

theory edhoc_psk_sapic

begin

builtins: diffie-hellman, hashing, xor

functions:
  method_four/0, length/0,
  hash_length/0, key_length/0, iv_length/0, plaintext_length/0, aead_length/0,
  edhoc_kdf/4,
  aeadenc/4, aeaddec/4 [destructor],
  make_id/1,
  wrap/1,
  hash/1, hkdfextract/2, hkdfexpand/2,
  encxor/2, decxor/2 [destructor],
  // Credential modeling functions
  make_cred/2,        // make_cred(subject_id, psk) -> credential
  get_subject/1      // get_subject(credential) -> subject_id  
  // get_psk/1          // get_psk(credential) -> psk

equations: 
  aeaddec(aeadenc(m,k,r,ad),k,r,ad) = m,
  decxor(encxor(m,k),k) = m,
  // Credential equations
  get_subject(make_cred(subject, psk)) = subject
  // get_psk(make_cred(subject, psk)) = psk,
  // make_id(cred_i) = make_id(cred_r)


let I(~cid, method, cred_i, cred_r, ~psk, ~id_cred_psk) = 
  // new suitesI;
  // new C_I;
  // new EAD_1;
  in(<suitesI,C_I,EAD_1>); // we let the attacker fully control the parameters used by a session

  event MethodOk(method);
  // event Debug_I_after_in(suitesI, C_I, EAD_1);
  
  new ~X; // DH share
  new ~EAD_3; // we model the EAD_3 as a fresh name to test later its secrecy
  event LeakShare(~X);
  event CompromiseShare(~X);

  let subject_i = get_subject(cred_i) in
  let subject_r = get_subject(cred_r) in
  let psk_from_cred_i = ~psk in  // get_psk(cred_i) in       
  let psk_from_cred_r = ~psk in  //get_psk(cred_r) in       
    
  if (psk_from_cred_i = ~psk) & (psk_from_cred_r = ~psk) then
    // if psk_from_cred_i = ~psk then  

    event Start_I(~cid, method, ~psk, subject_i);
    let G_X =  'g'^~X  in   
      
    let m1 = <method,suitesI,G_X,C_I,EAD_1> in
    out(m1);
    // event Debug_I_Sending_m1(m1);

    in(m2);
    // event Debug_I_Received_m2(m2);

    let < G_Y, CIPHERTEXT_2 > = m2 in
    let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
    let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in

    let G_YX = G_Y^~X in
    
    let PRK_2e = hkdfextract(TH_2, G_YX) in
    let KEYSTREAM_2A = edhoc_kdf(PRK_2e,'tzero',TH_2,plaintext_length) in
    let plaintext_2 = decxor(CIPHERTEXT_2, KEYSTREAM_2A) in
    let < C_R, EAD_2> = plaintext_2 in

    if method = method_four() then (

      let CRED_I = cred_i in
      let CRED_R = cred_r in
      // let ID_CRED_PSK = make_id(CRED_I) in
      let ID_CRED_PSK = ~id_cred_psk in

      let PRK_3e2m = PRK_2e in
      
      event DerivedIShared(G_YX);

      let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
      // event THIShared(TH_3); 

      let SALT_4e3m = edhoc_kdf(PRK_3e2m, 'five', TH_3, hash_length) in
      let PRK_4e3m = hkdfextract(psk_from_cred_i, SALT_4e3m) in
      
      let KEYSTREAM_3A = edhoc_kdf(PRK_3e2m, 'eleven', TH_3, plaintext_length) in
      let K_3 = edhoc_kdf(PRK_4e3m, 'twelve', TH_3, key_length) in
      let IV_3 = edhoc_kdf(PRK_3e2m, 'thirteen', TH_3, iv_length) in
      
      let external_aad_3 = <ID_CRED_PSK, TH_3, CRED_I, CRED_R> in
      let ad_3 = <'Encrypt0', 'empty', external_aad_3> in    
      let plaintext_3b = <~EAD_3> in    
      let ciphertext_3b = aeadenc(plaintext_3b, K_3, IV_3, ad_3) in
      let plaintext_3a = <ID_CRED_PSK, ciphertext_3b> in
      let m3 = encxor(plaintext_3a, KEYSTREAM_3A) in

      let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_I, CRED_R>) in
      let K_4 = edhoc_kdf(PRK_4e3m, 'eight', TH_4, key_length) in
      let IV_4 = edhoc_kdf(PRK_3e2m, 'nine', TH_4, iv_length) in
      let PRK_out = edhoc_kdf(PRK_4e3m, 'seven', TH_4, hash_length) in
      out(m3);
      // event Debug_I_Sending_m3(m3);

      event LeakSessionKey(PRK_out);

      in(m4);
      // event Debug_I_Received_m4(m4);

      let external_aad_4 = <TH_4> in
      let ad_4 = <'Encrypt0', 'empty', external_aad_4> in 
      let plaintext_4 = aeaddec(m4, K_4, IV_4, ad_4) in
      let EAD_4 = plaintext_4 in

      event AcceptI(~cid, method_four, subject_i, subject_r, PRK_out, ~X, G_Y);
      event FinishI(~cid, PRK_out);
      0
    ) else (
      0
    )
  else
    0

let R(~cid, cred_i, cred_r, ~psk, ~id_cred_psk) = 
  in(<C_R,EAD_2,suitesR>);

  in(m1);
  // event Debug_R_Received_m1(m1);
  let <method,suitesI,G_X,C_I,EAD_1> = m1 in
  //   in(<method, suitesI,G_X,C_I,EAD_1>);

  event MethodOk(method);  
  
  new ~Y;
  new ~EAD_4;
  event LeakShare(~Y);
  event CompromiseShare(~Y);

  let subject_i = get_subject(cred_i) in
  let subject_r = get_subject(cred_r) in
  let psk_from_cred_r = ~psk in // get_psk(cred_r) in
  let psk_from_cred_i = ~psk in // get_psk(cred_i) in
  
  if (psk_from_cred_i = ~psk) & (psk_from_cred_r = ~psk) then

    event Start_R(~cid, method, ~psk, subject_r);    

    let G_Y = 'g'^~Y in
    let G_XY = G_X^~Y in
    
    let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
    let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in
    let PRK_2e = hkdfextract(TH_2, G_XY) in

    if method = method_four() then (
      let plaintext_2 = <C_R, EAD_2> in
      let KEYSTREAM_2A = edhoc_kdf(PRK_2e, 'tzero', TH_2, plaintext_length) in
      event THRShared(TH_2); 	    
      event DerivedRShared(G_XY); 

      let m2 = <G_Y, encxor(plaintext_2, KEYSTREAM_2A)> in
      out(m2);
      // event Debug_R_Sending_m2(m2);

      in(m3);
      // event Debug_R_Receiving_m3(m3);
      let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
      let PRK_3e2m = PRK_2e in
      let SALT_4e3m = edhoc_kdf(PRK_3e2m,'five', TH_3, hash_length) in
      let PRK_4e3m = hkdfextract(psk_from_cred_r, SALT_4e3m) in
      let KEYSTREAM_3 = edhoc_kdf(PRK_3e2m,'eleven', TH_3,plaintext_length) in
      let K_3 = edhoc_kdf(PRK_4e3m,'twelve', TH_3, key_length) in
      let IV_3 = edhoc_kdf(PRK_3e2m,'thirteen', TH_3, iv_length) in
      let plaintext_3a = decxor(m3, KEYSTREAM_3) in
      
      let <ID_CRED_PSK_in, ciphertext_3b> = plaintext_3a in

      let CRED_I = cred_i in
      let CRED_R = cred_r in
      // FIXME: this should be make_id(CRED_R) but then it does not work.
      // let ID_CRED_PSK = make_id(CRED_I) in
      let ID_CRED_PSK = ~id_cred_psk in
          
      if ID_CRED_PSK_in = ID_CRED_PSK then
        // event Debug_R_check_psk(ID_CRED_PSK);

        let external_aad_3 = <ID_CRED_PSK, TH_3, CRED_I, CRED_R> in
        let ad_3 = <'Encrypt0', 'empty', external_aad_3> in
        let plaintext_3b = aeaddec(ciphertext_3b, K_3, IV_3, ad_3) in
        let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_I, CRED_R>) in
        let K_4 = edhoc_kdf(PRK_4e3m,'eight', TH_4, key_length) in
        let IV_4 = edhoc_kdf(PRK_3e2m, 'nine', TH_4, iv_length) in
        let PRK_out = edhoc_kdf(PRK_4e3m, 'seven', TH_4, hash_length) in
        let external_aad_4 = <TH_4> in
        let ad_4 = <'Encrypt0', 'empty', external_aad_4> in
        let m4 = aeadenc(~EAD_4, K_4, IV_4, ad_4) in
        out(m4);
        // event Debug_R_Sending_m4(m4);

        event AcceptR(~cid, method_four, subject_i, subject_r, PRK_out, G_X, ~Y);
        event FinishR(~cid, PRK_out);
        event LeakSessionKey(PRK_out);
        0
      else
        0
    ) else 
      0
  else 
    0

/* --------------------
   Main process
   -------------------- */
process:
  new ~psk;
  new ~id_cred_psk;
  new subject_i_main;
  new subject_r_main;
  new ~cid;

// attacker controlled tuples
  new suitesI0; new C_I0; new EAD_10;
  new C_R0; new EAD_20; new suitesR0;

  let method_fixed = method_four() in
  let cred_i = make_cred(subject_i_main, ~psk) in
  let cred_r = make_cred(subject_r_main, ~psk) in

  /* Provide the two initial attacker messages */
  out(<suitesI0, C_I0, EAD_10>);     /* will match I's first in(...) */
  out(<C_R0, EAD_20, suitesR0>);     /* will match R's first in(...) */

  event ExposeSubjectI(subject_i_main);
  event ExposeSubjectR(subject_r_main);
  event Honest(~psk);

  (
    I(~cid, method_fixed, cred_i, cred_r, ~psk, ~id_cred_psk) |
    R(~cid, cred_i, cred_r, ~psk, ~id_cred_psk)
  )

// RESTRICTIONS
// restriction Equality:
//   "All x y #i. Eq(x,y) @i ==> x = y"

restriction OnlyMethodFour:
  "All method #i. MethodOk(method) @i ==> method = method_four()"

// ******************************************************************
// ************** Executability  ************************************
// ******************************************************************
// PASSED
// tamarin-prover --prove=exec* edhoc_psk_tamarin.spthy --derivcheck-timeout=0 -s=10

lemma executableI_simple:
  exists-trace
  "Ex cid method psk subj_i #i. Start_I(cid, method, psk, subj_i) @i"

lemma executableR_simple:
  exists-trace
  "Ex cid method psk subj_r #i. Start_R(cid, method, psk, subj_r) @i"

// lemma executable_full_protocol:
//   exists-trace
//   "Ex cid1 cid2 prk1 prk2 #i #j.
//     FinishI(cid1, prk1) @i &
//     FinishR(cid2, prk2) @j &
//     prk1 = prk2"

// ******************************************************************
// ************** Confidentiality  **********************************
// ******************************************************************
// PASSED
lemma secretR_psk:
  "All cid subj_i subj_r prk gx y #i #j #k.
     AcceptR(cid, method_four, subj_i, subj_r, prk, gx, y)@i & K(prk)@j & ExposeSubjectR(subj_r)@k
   ==> (Ex #t. LeakSessionKey(prk)@t) 
    | (Ex #t. LeakShare(y)@t)
    | (Ex #t. LeakShare(gx)@t)"
// PASSED
lemma secretI_psk:
  "All cid subj_i subj_r prk x gy #i #j #k.
     AcceptI(cid, method_four, subj_i, subj_r, prk, x, gy)@i & K(prk)@j & ExposeSubjectI(subj_i)@k
   ==> (Ex #t. LeakSessionKey(prk)@t)
    | (Ex #t. LeakShare(x)@t)
    | (Ex #t. LeakShare(gy)@t)"

// ******************************************************************
// ************** Authentication  ***********************************
// ******************************************************************
// PASSED
lemma honestauthRI_psk_non_inj:
  "All cid subj_i subj_r prk gx y #i #k.
     AcceptR(cid, method_four, subj_i, subj_r, prk, gx, y)@i & ExposeSubjectI(subj_i)@k
   ==> (Ex cid2 prk2 x2 gy2 #t. AcceptI(cid2, method_four, subj_i, subj_r, prk2, x2, gy2)@t & t < i & prk = prk2)
    | (Ex #t. LeakShare(y)@t)"
// PASSED
lemma honestauthIR_psk_non_inj:
  "All cid subj_i subj_r prk x gy #i #k.
     AcceptI(cid, method_four, subj_i, subj_r, prk, x, gy)@i & ExposeSubjectR(subj_r)@k
   ==> (Ex cid2 prk2 gx2 y2 #j. AcceptR(cid2, method_four, subj_i, subj_r, prk2, gx2, y2)@j & j < i & prk = prk2)
    | (Ex #t. LeakShare(x)@t)"

// Uniqueness lemmas
// PAASED
lemma authRI_psk_unique:
  "All cid1 cid2 subj_i subj_r prk gx1 y1 gx2 y2 #i #j.
     AcceptR(cid1, method_four, subj_i, subj_r, prk, gx1, y1)@i & AcceptR(cid2, method_four, subj_i, subj_r, prk, gx2, y2)@j
   ==> #i = #j"

lemma authIR_psk_unique:
  "All cid1 cid2 subj_i subj_r prk x1 gy1 x2 gy2 #i #j.
     AcceptI(cid1, method_four, subj_i, subj_r, prk, x1, gy1)@i & AcceptI(cid2, method_four, subj_i, subj_r, prk, x2, gy2)@j
   ==> #i = #j"


// ******************************************************************
// ************** Key Agreement  ************************************
// ******************************************************************
// PASSED
// Not sure about this one...
// lemma key_agreement_psk:
//   "All cid1 cid2 subj_i subj_r prk1 prk2 gx gy x y #i #j.
//      AcceptI(cid1, method_four, subj_i, subj_r, prk1, x, gy)@i &
//      AcceptR(cid2, method_four, subj_i, subj_r, prk2, gx, y)@j
//    ==> prk1 = prk2"

// PASSED
lemma pfs_psk:
  "All cid subj_i subj_r prk x gy #i #j #k.
     AcceptI(cid, method_four, subj_i, subj_r, prk, x, gy)@i & K(prk)@j & ExposeSubjectI(subj_i)@k
   ==> (Ex #t. LeakShare(x)@t & t < i)
    | (Ex #t. LeakShare(gy)@t & t < i)
    | (Ex #t. LeakSessionKey(prk)@t)"

// ******************************************************************
// ************** Additional Security Properties  *******************
// ******************************************************************
// PASSED
// Strong secrecy of session key if no DH leak
// lemma session_key_secrecy:
//   "All cid prk #i.
//     FinishI(cid, prk)@i ==> not (Ex #j. K(prk)@j & not (Ex #k. LeakSessionKey(prk)@k))"

// PASSED
// lemma subject_psk_consistency:
//   "All cid1 cid2 subj_i subj_r prk1 prk2 gx1 gy1 gx2 gy2 #i #j.
//      AcceptI(cid1, method_four, subj_i, subj_r, prk1, gx1, gy1)@i &
//      AcceptR(cid2, method_four, subj_i, subj_r, prk2, gx2, gy2)@j
//    ==> prk1 = prk2"

// ******************************************************************
// ************** Identity binding***********************************
// ******************************************************************
// PASSED
lemma identity_binding:
  "All cid subj_i subj_r prk x gy #i.
     AcceptI(cid, method_four, subj_i, subj_r, prk, x, gy)@i
   ==> (Ex #j. ExposeSubjectI(subj_i)@j) & (Ex #k. ExposeSubjectR(subj_r)@k)"

// Subject authenticity - responder knows initiator's real identity
lemma subject_authenticity_R:
  "All cid subj_i subj_r prk gx y #i #j #k.
     AcceptR(cid, method_four, subj_i, subj_r, prk, gx, y)@i & 
     ExposeSubjectI(subj_i)@j & ExposeSubjectR(subj_r)@k
   ==> (Ex cid2 prk2 x2 gy2 #t. AcceptI(cid2, method_four, subj_i, subj_r, prk2, x2, gy2)@t)
    | (Ex #t. LeakShare(y)@t)"

// Subject authenticity - initiator knows responder's real identity  
lemma subject_authenticity_I:
  "All cid subj_i subj_r prk x gy #i #j #k.
     AcceptI(cid, method_four, subj_i, subj_r, prk, x, gy)@i & 
     ExposeSubjectI(subj_i)@j & ExposeSubjectR(subj_r)@k
   ==> (Ex cid2 prk2 gx2 y2 #t. AcceptR(cid2, method_four, subj_i, subj_r, prk2, gx2, y2)@t)
    | (Ex #t. LeakShare(x)@t)"

end