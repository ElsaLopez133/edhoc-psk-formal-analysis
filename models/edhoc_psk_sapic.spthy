/*
 * Protocol:   EDHOC-PSK
 * Source:     draft-ietf-lake-edhoc-psk
 * Model:      Fixed for concurrent sessions

 Scenarios to check ideally:
 - `tamarin-prover -D=LeakShare`
 - `tamarin-prover -D=LeakSKey`
*/

theory edhoc_psk_sapic

begin

builtins: diffie-hellman, hashing, xor

functions:
  method_four/0, length/0,
  hash_length/0, key_length/0, iv_length/0, plaintext_length/0, aead_length/0,
  edhoc_kdf/4,
  aeadenc/4, aeaddec/4 [destructor],
  wrap/1,
  hash/1, hkdfextract/2, hkdfexpand/2,
  encxor/2, decxor/2 [destructor],

  // Credential modeling functions
  make_id/3,           // make_id(cred_i, cred_r, psk) -> ID_CRED_PSK
  get_cred/3 [destructor] 

equations:
  aeaddec(aeadenc(m,k,r,ad),k,r,ad) = m,
  decxor(encxor(m,k),k) = m,
  get_cred(make_id(credI, credR, psk), psk, credR) = credI,

#include "Headers.splib"

heuristic:s

/* -------------------- Initiator -------------------- */
let I(~cid, method, ~credI, ~psk, ~cred) =
  in(<suitesI,C_I,EAD_1>);
  event MethodOk(method);

  let CRED_I = ~credI in
  let CRED_R = ~cred in
  let ID_CRED_PSK = make_id(CRED_I, CRED_R, ~psk) in

  new ~X;
  new ~EAD_3;

  event Share(~X);
  event LeakEAD(~EAD_3);

  // We check that we are not talking to oursevles
  if CRED_I = CRED_R then(
    0
  ) else
  (
    CompromiseShare(~X) |
    event InitiateWithID(CRED_I, CRED_R);
    event StartI(~cid, method, CRED_I, CRED_R, ~psk);

    let G_X = 'g'^~X in
    let m1 = <method,suitesI,G_X,C_I,EAD_1> in
    out(m1);

    in(m2);
    event ReceivedRData(~cid, method, CRED_I, CRED_R, ~psk, ~X, m2);

    let < G_Y, CIPHERTEXT_2 > = m2 in
    let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
    let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in

    let G_YX = G_Y^~X in
    let PRK_2e = hkdfextract(TH_2, G_YX) in
    let KEYSTREAM_2A = edhoc_kdf(PRK_2e,'tzero',TH_2,plaintext_length) in
    let plaintext_2 = decxor(CIPHERTEXT_2, KEYSTREAM_2A) in
    let < C_R, EAD_2> = plaintext_2 in

    // if (check_grp(G_Y) = grpid) then  // Not in the standard: we test against the value testgrpid, which is either a useless constant or the neutral element of the group.
      //  0
    // else 
      if method = method_four() then (
        let PRK_3e2m = PRK_2e in
        event DerivedIShared(G_YX);

        let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
        let SALT_4e3m = edhoc_kdf(PRK_3e2m, 'five', TH_3, hash_length) in
        let PRK_4e3m = hkdfextract(~psk, SALT_4e3m) in

        let KEYSTREAM_3A = edhoc_kdf(PRK_3e2m, 'eleven', TH_3, plaintext_length) in
        let K_3 = edhoc_kdf(PRK_4e3m, 'twelve', TH_3, key_length) in
        let IV_3 = edhoc_kdf(PRK_3e2m, 'thirteen', TH_3, iv_length) in

        let external_aad_3 = <ID_CRED_PSK, TH_3, CRED_I, CRED_R> in
        let ad_3 = <'Encrypt0','empty',external_aad_3> in
        let plaintext_3b = <~EAD_3> in
        let ciphertext_3b = aeadenc(plaintext_3b, K_3, IV_3, ad_3) in
        let plaintext_3a = <ID_CRED_PSK, ciphertext_3b> in
        let m3 = encxor(plaintext_3a, KEYSTREAM_3A) in

        let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK, plaintext_3b, CRED_I, CRED_R>) in
        let K_4 = edhoc_kdf(PRK_4e3m,'eight', TH_4, key_length) in
        let IV_4 = edhoc_kdf(PRK_3e2m,'nine', TH_4, iv_length) in
        let PRK_out = edhoc_kdf(PRK_4e3m,'seven', TH_4, hash_length) in
        event DerivedI(~cid, method, CRED_I, CRED_R, PRK_out, ~X, G_Y, ~psk);
        event ExplicitDerivedI(~cid, method, CRED_I, CRED_R, PRK_out, ~X, G_Y, ~psk, G_YX);
        event SendIData(PRK_out, method, CRED_I, CRED_R, ~psk,~X,G_Y,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, ~EAD_3, m1, plaintext_2, plaintext_3a>);
        event SendIm3(~cid, method, CRED_I, CRED_R, ~psk, ~X, G_Y, m3);
        out(m3);
        event TransmitEAD(m3, ~EAD_3, PRK_4e3m);
      
        ( 
            (
                in(m4);
                let external_aad_4 = <TH_4> in
                let ad_4 = <'Encrypt0','empty',external_aad_4> in
                let plaintext_4 = aeaddec(m4, K_4, IV_4, ad_4) in
                let EAD_4 = plaintext_4 in
                event AcceptIData(PRK_out, method, CRED_I, CRED_R, ~psk,~X,G_Y,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, ~EAD_3, m1, plaintext_2, plaintext_3a, plaintext_4>);
                event AcceptI(~cid, method, CRED_I, CRED_R, PRK_out, ~X, G_Y, ~psk);
                0
            )
            |
            leakSKey(PRK_out)
        )
      ) else (0)
  )

/* -------------------- Responder -------------------- */
let R(~cid, ~idR, ~psk) =
  in(<C_R,EAD_2,suitesR>);
  in(m1);
  let <method,suitesI,G_X,C_I,EAD_1> = m1 in
  event MethodOk(method);

  let CRED_R = ~idR in
  new ~Y;
  new ~EAD_4;
  event Share(~Y);
  event LeakEAD(~EAD_4);

  (
    CompromiseShare(~Y) |
    event RespondWithID(CRED_R);
    event StartR(~cid, method, CRED_R, ~psk);

    let G_Y = 'g'^~Y in
    let G_XY = G_X^~Y in

    let TH_1 = hash(<wrap(method), wrap(suitesI), wrap(G_X), wrap(C_I), EAD_1>) in
    let TH_2 = hash(<wrap(G_Y), wrap(TH_1)>) in
    let PRK_2e = hkdfextract(TH_2, G_XY) in

    // if (check_grp(G_X) = grpid) then  // Not in the standard: we test against the value testgrpid, which is either a useless constant or the neutral element of the group.
      //  0
    // else 

    if method = method_four() then (
      let plaintext_2 = <C_R, EAD_2> in
      let KEYSTREAM_2A = edhoc_kdf(PRK_2e,'tzero', TH_2, plaintext_length) in
      event THRShared(TH_2);
      event DerivedRShared(G_XY);

      let m2 = <G_Y, encxor(plaintext_2, KEYSTREAM_2A)> in
      event SendRData(~cid, method, CRED_R, ~psk, m2);							    
      out(m2);

      in(m3);

      let TH_3 = hash(<wrap(TH_2), plaintext_2>) in
      let PRK_3e2m = PRK_2e in
      let KEYSTREAM_3 = edhoc_kdf(PRK_3e2m,'eleven', TH_3, plaintext_length) in
      let plaintext_3a = decxor(m3, KEYSTREAM_3) in
      let <ID_CRED_PSK_in, ciphertext_3b> = plaintext_3a in

      let CRED_I = get_cred(ID_CRED_PSK_in, ~psk, CRED_R) in
      // let PSK_in = get_psk(ID_CRED_PSK_in) in
      
      if CRED_I = CRED_R then (
        0
      ) else

      event ReceivedRm3(~cid, method, CRED_I, CRED_R, ~psk, ~Y, G_X, m3);
      (
        // if PSK_in = ~psk then (
          let SALT_4e3m = edhoc_kdf(PRK_3e2m,'five', TH_3, hash_length) in
          let PRK_4e3m = hkdfextract(~psk, SALT_4e3m) in
          let K_3 = edhoc_kdf(PRK_4e3m,'twelve', TH_3, key_length) in
          let IV_3 = edhoc_kdf(PRK_3e2m,'thirteen', TH_3, iv_length) in

          let external_aad_3 = <ID_CRED_PSK_in, TH_3, CRED_I, CRED_R> in
          let ad_3 = <'Encrypt0','empty',external_aad_3> in
          let plaintext_3b = aeaddec(ciphertext_3b, K_3, IV_3, ad_3) in
          let <EAD_3> = plaintext_3b in
          let TH_4 = hash(<wrap(TH_3), ID_CRED_PSK_in, plaintext_3b, CRED_I, CRED_R>) in
          let K_4 = edhoc_kdf(PRK_4e3m,'eight', TH_4, key_length) in
          let IV_4 = edhoc_kdf(PRK_3e2m,'nine', TH_4, iv_length) in
          let PRK_out = edhoc_kdf(PRK_4e3m,'seven', TH_4, hash_length) in
          let external_aad_4 = <TH_4> in
          let ad_4 = <'Encrypt0','empty',external_aad_4> in
          let m4 = aeadenc(~EAD_4, K_4, IV_4, ad_4) in
          event DerivedR(~cid,PRK_out,~Y,G_X, ~psk);
          event TransmitEAD(m4, ~EAD_4, PRK_out);
          event AcceptR(~cid, method, CRED_I, CRED_R, PRK_out, G_X, ~Y, ~psk);
          event AcceptRData(PRK_out, method, CRED_I, CRED_R, ~psk,~Y,G_X,<TH_2,TH_3,TH_4,suitesI, EAD_1, EAD_2, EAD_3, m1, plaintext_2, plaintext_3a>);
          out(m4);
          (
              0 
              |
              leakSKey(PRK_out)
          )
        // ) else (0)
    ) else (0)
    )
  )

/* -------------------- Main Process -------------------- */
let compromise(psk) =
    in('Comp'); event Compromise(psk); event SharePSK(psk); out(psk)

process:
  !(new ~psk; 
    event Honest(~psk);

    !(new ~cid; new ~id;
      // Identites are publicly known
      event HonestSubject(~id);
      out(~id);

      ( ( !in(cred); I(~cid, method_four(), ~id, ~psk, cred))
        |
        (!R(~cid, ~id, ~psk))
        |
        (compromise(~psk))
      )
    )
  )



#include "LakePropertiesPSK.splib"

// === Diff-equivalence (initiator anonymity, passive attacker) ===

#ifdef diffEquiv

// diffEquivLemma: // Anonymity as a diff equivalence
// !(new ~psk1; event Honest(~psk1);
//   // new ~psk2; event Honest(~psk2);

//   !(new ~cid1; new ~id1;
//     event HonestSubject(~id1);
//     out(~id1);

//     new ~cid2; new ~id2;
//     event HonestSubject(~id2);
//     out(~id2);

//     new ~idR;
//     event HonestSubject(~idR);
//     out(~idR);

//     ( 
//       ( !I(~cid1, method_four(), ~id1, ~psk1, ~idR)) 
//       | 
//       ( !I(~cid2, method_four(), ~id2, ~psk1, ~idR))
//       |
//       (!R(~cid1, ~idR, ~psk1))
//       |
//       (!I(diff(~cid1,~cid2), method_four(), diff(~id1,~id2), ~psk1, ~idR)) // test scenarios with idR as Responder
//     )
//   )
// )

// only two
diffEquivLemma: // Anonymity as a diff equivalence
!(
  new ~psk1; event Honest(~psk1);
  // new ~psk2; event Honest(~psk2);

  (
    new ~cid1; new ~id1;
    event HonestSubject(~id1);
    out(~id1);

    new ~cid2; new ~id2;
    event HonestSubject(~id2);
    out(~id2);

    ( 
      (I(diff(~cid1,~cid2), method_four(), diff(~id1,~id2), ~psk1, ~id1)) // test scenarios with id3 as Responder
      |       
      (!R(~cid1, ~id1, ~psk1))
    )
  )
)

#endif


// === Equivalence (initiator anonymity, passive attacker) ===

#ifdef EquivLemmas

equivLemma:
(new ~psk1;
 event Honest(~psk1); 
  (
    new ~cid1; new ~id1; new ~idR1;
    out(~id1);
    out(~idR1);

    (
      I(~cid1, method_four(), ~id1, ~psk1, ~idR1)
    |  R(~cid1, ~idR1, ~psk1 )
      // passive attacker -> do NOT include compromise(~psk1)
    )
  )
)

(
  new ~psk2;
  event Honest(~psk2);
  (
    new ~cid2; new ~id2; new ~idR2;
    out(~id2);
    out(~idR2);

    (
      I(~cid2, method_four(), ~id2, ~psk2, ~idR2)
    |  R(~cid2, ~idR2, ~psk2 )
      // passive attacker -> do NOT include compromise(~psk2)
    )
  )
)

#endif

/* -------------------- Restrictions -------------------- */

restriction OnlyMethodFour:
  "All method #i. MethodOk(method) @i ==> method = method_four()"

end