const g:bitstring.
free att:channel.
free sComp:bitstring.
free sEncrypt0:bitstring.
free seight:bitstring.
free seleven:bitstring.
free sempty:bitstring.
free sfive:bitstring.
free snine:bitstring.
free sseven:bitstring.
free sthirteen:bitstring.
free stwelve:bitstring.
free stzero:bitstring.
fun aead_length():bitstring.
fun aeadenc(bitstring,bitstring,bitstring,bitstring):bitstring.
fun const_grp():bitstring.
fun edhoc_kdf(bitstring,bitstring,bitstring,bitstring):bitstring.
fun encxor(bitstring,bitstring):bitstring.
fun exp(bitstring,bitstring):bitstring.
fun fst(bitstring):bitstring.
fun h(bitstring):bitstring.
fun hash(bitstring):bitstring.
fun hash_length():bitstring.
fun hkdfexpand(bitstring,bitstring):bitstring.
fun hkdfextract(bitstring,bitstring):bitstring.
fun iv_length():bitstring.
fun key_length():bitstring.
fun length():bitstring.
fun make_cred(bitstring,bitstring):bitstring.
fun make_id(bitstring,bitstring,bitstring):bitstring.
fun method_four():bitstring.
fun pair(bitstring,bitstring):bitstring.
fun plaintext_length():bitstring.
fun snd(bitstring):bitstring.
fun wrap(bitstring):bitstring.
fun xor(bitstring,bitstring):bitstring.
fun zero():bitstring.
event eAcceptI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptIData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptRData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eCompromise(bitstring).
event eDerivedI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eDerivedIShared(bitstring).
event eDerivedR(bitstring,bitstring,bitstring,bitstring,bitstring).
event eDerivedRShared(bitstring).
event eExposeSubjectI(bitstring).
event eExposeSubjectR(bitstring).
event eFinishI(bitstring,bitstring).
event eFinishR(bitstring,bitstring).
event eHonest(bitstring).
event eHonestSubjectI(bitstring).
event eHonestSubjectR(bitstring).
event eInitiateWithID(bitstring,bitstring).
event eLeakEAD(bitstring).
event eLeakSessionKey(bitstring).
event eLeakShare(bitstring).
event eMethodOk(bitstring).
event eRespondWithID(bitstring,bitstring).
event eSendIData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSendRData(bitstring,bitstring,bitstring,bitstring,bitstring).
event eShare(bitstring).
event eSharePSK(bitstring).
event eStart_I(bitstring,bitstring,bitstring).
event eStart_R(bitstring,bitstring,bitstring).
event eTHRShared(bitstring).
event eTransmitEAD(bitstring,bitstring,bitstring).
equation forall a:bitstring,b:bitstring; exp( exp(g,a),b) = exp(exp(g,b),a).
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
reduc forall ad:bitstring, k:bitstring, m:bitstring, r:bitstring;   aeaddec(aeadenc(m, k, r, ad), k, r, ad) = m.
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_cred_i(make_id(cred_i, cred_r, psk)) = cred_i [private].
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_cred_r(make_id(cred_i, cred_r, psk)) = cred_r [private].
reduc forall cred_i:bitstring, cred_r:bitstring, psk:bitstring;   get_psk(make_id(cred_i, cred_r, psk)) = psk [private].
reduc forall k:bitstring, m:bitstring;   decxor(encxor(m, k), k) = m.
reduc forall psk:bitstring, subject:bitstring;   get_subject(make_cred(subject, psk)) = subject.
reduc forall x:bitstring;   check_grp(x) = const_grp.
(*secretR_psk*)
query cid:bitstring, gx:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, y:bitstring, i:time,
      j:time, k:time, t:time;
 (((event(eAcceptR( cid, m, subj_i, subj_r, prk, gx, y, psk ))@i) &&
   (attacker( prk )@j)) &&
  (event(eHonest( psk ))@k)) ==>
 (((event(eCompromise( psk ))@t) && (t < j)) ||
  (event(eLeakSessionKey( prk ))@t))
.
(*secretI_psk*)
query cid:bitstring, gy:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, x:bitstring, i:time,
      j:time, k:time, t:time;
 (((event(eAcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ))@i) &&
   (attacker( prk )@j)) &&
  (event(eHonest( psk ))@k)) ==>
 (((event(eCompromise( psk ))@t) && (t < j)) ||
  (event(eLeakSessionKey( prk ))@t))
.
(*honestauthRI_psk_non_inj*)
query cid:bitstring, cid2:bitstring, gx:bitstring, gy2:bitstring,
      m:bitstring, prk:bitstring, prk2:bitstring, psk:bitstring,
      subj_i:bitstring, subj_r:bitstring, x2:bitstring, y:bitstring, i:time,
      k:time, t:time;
 ((event(eAcceptR( cid, m, subj_i, subj_r, prk, gx, y, psk ))@i) &&
  (event(eHonest( psk ))@k)) ==>
 ((((event(eDerivedI( cid2, m, subj_i, subj_r, prk2, x2, gy2, psk ))@t) &&
    (t < i)) &&
   (prk = prk2)) ||
  ((event(eCompromise( psk ))@t) && (t < i)))
.
(*honestauthIR_psk_non_inj*)
query cid:bitstring, cid2:bitstring, gx2:bitstring, gy:bitstring,
      m:bitstring, prk:bitstring, prk2:bitstring, psk:bitstring,
      subj_i:bitstring, subj_r:bitstring, x:bitstring, y2:bitstring, i:time,
      j:time, k:time, t:time;
 ((event(eAcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ))@i) &&
  (event(eHonest( psk ))@k)) ==>
 ((((event(eAcceptR( cid2, m, subj_i, subj_r, prk2, gx2, y2, psk ))@j) &&
    (j < i)) &&
   (prk = prk2)) ||
  ((event(eCompromise( psk ))@t) && (t < i)))
.
(*authR_injective*)
(*∀ cid1 cid2 m subj_i subj_r prk gx1 gx2 y1 y2 psk #i.1 #j.1 #k.
   (((AcceptR( cid1, m, subj_i, subj_r, prk, gx1, y1, psk ) @ #i.1) ∧
     (AcceptR( cid2, m, subj_i, subj_r, prk, gx2, y2, psk ) @ #j.1)) ∧
    (Honest( psk ) @ #k)) ⇒
   (((i = j) ∨ (∃ #t. (Compromise( psk ) @ #t) ∧ (#t < #i.1))) ∨
    (∃ #t. (Compromise( psk ) @ #t) ∧ (#t < #j.1)))*)
(*authI_injective*)
(*∀ cid1 cid2 m subj_i subj_r prk x1 x2 gy1 gy2 psk #i.1 #j.1 #k.
   (((AcceptI( cid1, m, subj_i, subj_r, prk, x1, gy1, psk ) @ #i.1) ∧
     (AcceptI( cid2, m, subj_i, subj_r, prk, x2, gy2, psk ) @ #j.1)) ∧
    (Honest( psk ) @ #k)) ⇒
   (((i = j) ∨ (∃ #t. (Compromise( psk ) @ #t) ∧ (#t < #i.1))) ∨
    (∃ #t. (Compromise( psk ) @ #t) ∧ (#t < #j.1)))*)
(*data_authentication_I_to_R*)
query EAD_1:bitstring, EAD_2:bitstring, EAD_3:bitstring,
      PRK_out:bitstring, TH_2:bitstring, TH_3:bitstring, TH_4:bitstring,
      gx:bitstring, gy:bitstring, m1:bitstring, method:bitstring, p2:bitstring,
      p3:bitstring, p4:bitstring, psk:bitstring, subject_i:bitstring,
      subjetc_r:bitstring, suitesI:bitstring, x:bitstring, y:bitstring, i:time,
      j:time, l:time;
 ((event(eAcceptIData( PRK_out, method, subject_i, subjetc_r, psk, x, gy,
                       (TH_2, (TH_3, (TH_4, (suitesI, (EAD_1, (EAD_2, (EAD_3, (m1, (p2, (p3, p4))))))))))
         ))@i) &&
  (event(eHonest( psk ))@j)) ==>
 (((l < i) &&
   (event(eAcceptRData( PRK_out, method, subject_i, subjetc_r, psk, y, gx,
                        (TH_2, (TH_3, (TH_4, (suitesI, (EAD_1, (EAD_2, (EAD_3, (m1, (p2, p3)))))))))
          ))@l)) ||
  ((l < i) && (event(eCompromise( psk ))@l)))
.
(*data_authentication_R_to_I*)
query EAD_1:bitstring, EAD_2:bitstring, EAD_3:bitstring,
      PRK_out:bitstring, TH_2:bitstring, TH_3:bitstring, TH_4:bitstring,
      gx:bitstring, gy:bitstring, m1:bitstring, method:bitstring, p2:bitstring,
      p3:bitstring, psk:bitstring, subject_i:bitstring, subjetc_r:bitstring,
      suitesI:bitstring, x:bitstring, y:bitstring, i:time, j:time, l:time;
 ((event(eAcceptRData( PRK_out, method, subject_i, subjetc_r, psk, y, gx,
                       (TH_2, (TH_3, (TH_4, (suitesI, (EAD_1, (EAD_2, (EAD_3, (m1, (p2, p3)))))))))
         ))@i) &&
  (event(eHonest( psk ))@j)) ==>
 (((l < i) &&
   (event(eSendIData( PRK_out, method, subject_i, subjetc_r, psk, x, gy,
                      (TH_2, (TH_3, (TH_4, (suitesI, (EAD_1, (EAD_2, (EAD_3, (m1, (p2, p3)))))))))
          ))@l)) ||
  ((l < i) && (event(eCompromise( psk ))@l)))
.
(*key_agreement_R_implies_I*)
query PRK_out:bitstring, cid:bitstring, gx:bitstring, gy:bitstring,
      method:bitstring, psk:bitstring, subj_i:bitstring, subj_r:bitstring,
      x:bitstring, y:bitstring, i:time, j:time, k:time, psk_1:bitstring;
 (event(eAcceptR( cid, method, subj_i, subj_r, PRK_out, gx, y, psk
        ))@j) ==>
 (((i < j) &&
   (event(eDerivedI( cid, method, subj_i, subj_r, PRK_out, x, gy, psk
          ))@i)) ||
  (event(eCompromise( psk_1 ))@k))
.
(*key_agreement_I_implies_R*)
query PRK_out:bitstring, cid:bitstring, gx:bitstring, gy:bitstring,
      method:bitstring, psk:bitstring, subj_i:bitstring, subj_r:bitstring,
      x:bitstring, y:bitstring, i:time, j:time, k:time, psk_1:bitstring;
 (event(eAcceptI( cid, method, subj_i, subj_r, PRK_out, x, gy, psk
        ))@i) ==>
 (((j < i) &&
   (event(eAcceptR( cid, method, subj_i, subj_r, PRK_out, gx, y, psk
          ))@j)) ||
  (event(eCompromise( psk_1 ))@k))
.
(*weak_pfs*)
query cid:bitstring, gx:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, y:bitstring, i:time,
      j:time, k:time, t:time;
 (((event(eAcceptR( cid, m, subj_i, subj_r, prk, gx, y, psk ))@i) &&
   (attacker( prk )@j)) &&
  (event(eHonest( psk ))@k)) ==>
 ((event(eLeakSessionKey( prk ))@t) ||
  ((t < i) && (event(eCompromise( psk ))@t)))
.
(*strong_pfs*)
(*∀ cid m subj_i subj_r prk psk gy x #i #j.
   (((AcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ) @ #i) ∧
     (Compromise( psk ) @ #j)) ∧
    (#i < #j)) ⇒
   ((((¬(∃ #t. K( prk ) @ #t)) ∨
      (∃ #t. (ExposeSubjectI( subj_i ) @ #t) ∧ (#t < #i))) ∨
     (∃ #t. (LeakSessionKey( prk ) @ #t) ∧ (#t < #i))) ∨
    (∃ #t. (LeakShare( x ) @ #t) ∧ (#t < #i)))*)
(*explicit_key_confirmation_I*)
query cid:bitstring, cid2:bitstring, gx2:bitstring, gy:bitstring,
      m:bitstring, prk:bitstring, prk2:bitstring, psk:bitstring,
      subj_i:bitstring, subj_r:bitstring, x:bitstring, y2:bitstring, i:time,
      t:time, psk_1:bitstring;
 (event(eAcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ))@i) ==>
 (((event(eAcceptR( cid2, m, subj_i, subj_r, prk2, gx2, y2, psk_1 ))@t) &&
   (prk = prk2)) ||
  (event(eCompromise( psk_1 ))@t))
.
(*identity_binding_I*)
query cid:bitstring, gy:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, x:bitstring, i:time,
      j:time;
 (event(eAcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ))@i) ==>
 (event(eInitiateWithID( subj_i, subj_r ))@j)
.
(*identity_binding_R*)
query cid:bitstring, gx:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, y:bitstring, i:time,
      j:time;
 (event(eAcceptR( cid, m, subj_i, subj_r, prk, gx, y, psk ))@i) ==>
 (event(eRespondWithID( subj_i, subj_r ))@j)
.
(*no_passive_impersonation_I*)
query cid:bitstring, gy:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, x:bitstring, i:time,
      j:time, psk_1:bitstring;
 (event(eAcceptI( cid, m, subj_i, subj_r, prk, x, gy, psk ))@i) ==>
 (event(eHonest( psk_1 ))@j)
.
(*no_passive_impersonation_R*)
query cid:bitstring, gx:bitstring, m:bitstring, prk:bitstring,
      psk:bitstring, subj_i:bitstring, subj_r:bitstring, y:bitstring, i:time,
      j:time, psk_1:bitstring;
 (event(eAcceptR( cid, m, subj_i, subj_r, prk, y, gx, psk ))@i) ==>
 (event(eHonest( psk_1 ))@j)
.
let CompromiseShare(s_2:bitstring)=
    event eLeakShare( s_2 );
    event eLeakShare( exp(g, s_2) );
    out(att,s_2).
let leakSKey(key_2:bitstring)=
    event eLeakSessionKey( key_2 );
    out(att,key_2).
let I(cid_2:bitstring, method_2:bitstring, ID_CRED_PSK_2:bitstring)=
    in(att,(suitesI_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring)));
    event eMethodOk( method_2 );
    new X_2:bitstring;
    new EAD_3_2:bitstring;
    event eShare( X_2 );
    event eLeakEAD( EAD_3_2 );
    ((CompromiseShare(X_2))
   | (let CRED_I_2:bitstring=get_cred_i(ID_CRED_PSK_2) in
      let CRED_R_2:bitstring=get_cred_r(ID_CRED_PSK_2) in
      let psk_2:bitstring=get_psk(ID_CRED_PSK_2) in
      let subject_i_2:bitstring=get_subject(CRED_I_2) in
      let subject_r_2:bitstring=get_subject(CRED_R_2) in
      event eInitiateWithID( subject_i_2, subject_r_2 );
      event eStart_I( cid_2, method_2, subject_i_2 );
      let G_X_2:bitstring=exp(g, X_2) in
      let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
      out(att,m1_2);
      in(att,m2_2:bitstring);
      let (G_Y_2:bitstring, CIPHERTEXT_2_2:bitstring)=m2_2 in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let G_YX_2:bitstring=exp(G_Y_2, X_2) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_YX_2) in
      let KEYSTREAM_2A_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                             plaintext_length) in
      let plaintext_2_2:bitstring=decxor(CIPHERTEXT_2_2, KEYSTREAM_2A_2) in
      let (C_R_2:bitstring, EAD_2_2:bitstring)=plaintext_2_2 in
      let (=method_2)=method_four in 
          (let PRK_3e2m_2:bitstring=PRK_2e_2 in
           event eDerivedIShared( G_YX_2 );
           let TH_3_2:bitstring=hash((wrap(TH_2_2), plaintext_2_2)) in
           let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                               hash_length) in
           let PRK_4e3m_2:bitstring=hkdfextract(psk_2, SALT_4e3m_2) in
           let KEYSTREAM_3A_2:bitstring=edhoc_kdf(PRK_3e2m_2, seleven, TH_3_2,
                                                  plaintext_length) in
           let K_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, stwelve, TH_3_2, key_length) in
           let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthirteen, TH_3_2,
                                          iv_length) in
           let external_aad_3_2:bitstring=(ID_CRED_PSK_2, (TH_3_2, (CRED_I_2, CRED_R_2))) in
           let ad_3_2:bitstring=(sEncrypt0, (sempty, external_aad_3_2)) in
           let plaintext_3b_2:bitstring=EAD_3_2 in
           let ciphertext_3b_2:bitstring=aeadenc(plaintext_3b_2, K_3_2, IV_3_2,
                                                 ad_3_2) in
           let plaintext_3a_2:bitstring=(ID_CRED_PSK_2, ciphertext_3b_2) in
           let m3_2:bitstring=encxor(plaintext_3a_2, KEYSTREAM_3A_2) in
           let TH_4_2:bitstring=hash((wrap(TH_3_2), (ID_CRED_PSK_2, (plaintext_3b_2, (CRED_I_2, CRED_R_2))))) in
           let K_4_2:bitstring=edhoc_kdf(PRK_4e3m_2, seight, TH_4_2, key_length) in
           let IV_4_2:bitstring=edhoc_kdf(PRK_3e2m_2, snine, TH_4_2, iv_length) in
           let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                             hash_length) in
           event eDerivedI( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                            X_2, G_Y_2, psk_2
                 );
           event eSendIData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                             X_2, G_Y_2,
                             (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3a_2)))))))))
                 );
           out(att,m3_2);
           event eTransmitEAD( m3_2, EAD_3_2, PRK_4e3m_2 );
           ((in(att,m4_2:bitstring);
             let external_aad_4_2:bitstring=TH_4_2 in
             let ad_4_2:bitstring=(sEncrypt0, (sempty, external_aad_4_2)) in
             let plaintext_4_2:bitstring=aeaddec(m4_2, K_4_2, IV_4_2, ad_4_2) in
             let EAD_4_2:bitstring=plaintext_4_2 in
             event eAcceptIData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                                 X_2, G_Y_2,
                                 (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, (plaintext_3a_2, plaintext_4_2))))))))))
                   );
             event eAcceptI( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                             X_2, G_Y_2, psk_2
                   );
             event eFinishI( cid_2, PRK_out_2 ))
          | (leakSKey(PRK_out_2)))))).
let R(cid_2:bitstring, ID_CRED_PSK_2:bitstring)=
    in(att,(C_R_2:bitstring, (EAD_2_2:bitstring, suitesR_2:bitstring)));
    in(att,m1_2:bitstring);
    let (method_2:bitstring, (suitesI_2:bitstring, (G_X_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring))))=m1_2 in
    event eMethodOk( method_2 );
    new Y_2:bitstring;
    new EAD_4_2:bitstring;
    event eShare( Y_2 );
    event eLeakEAD( EAD_4_2 );
    ((CompromiseShare(Y_2))
   | (let CRED_I_2:bitstring=get_cred_i(ID_CRED_PSK_2) in
      let CRED_R_2:bitstring=get_cred_r(ID_CRED_PSK_2) in
      let psk_2:bitstring=get_psk(ID_CRED_PSK_2) in
      let subject_i_2:bitstring=get_subject(CRED_I_2) in
      let subject_r_2:bitstring=get_subject(CRED_R_2) in
      event eRespondWithID( subject_i_2, subject_r_2 );
      event eStart_R( cid_2, method_2, subject_r_2 );
      let G_Y_2:bitstring=exp(g, Y_2) in
      let G_XY_2:bitstring=exp(G_X_2, Y_2) in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_XY_2) in
      let (=method_2)=method_four in 
          (let plaintext_2_2:bitstring=(C_R_2, EAD_2_2) in
           let KEYSTREAM_2A_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                                  plaintext_length) in
           event eTHRShared( TH_2_2 );
           event eDerivedRShared( G_XY_2 );
           let m2_2:bitstring=(G_Y_2, encxor(plaintext_2_2, KEYSTREAM_2A_2)) in
           event eSendRData( method_2, subject_i_2, subject_r_2, psk_2,
                             (TH_2_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (m1_2, plaintext_2_2)))))
                 );
           out(att,m2_2);
           in(att,m3_2:bitstring);
           let TH_3_2:bitstring=hash((wrap(TH_2_2), plaintext_2_2)) in
           let PRK_3e2m_2:bitstring=PRK_2e_2 in
           let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                               hash_length) in
           let PRK_4e3m_2:bitstring=hkdfextract(psk_2, SALT_4e3m_2) in
           let KEYSTREAM_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, seleven, TH_3_2,
                                                 plaintext_length) in
           let K_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, stwelve, TH_3_2, key_length) in
           let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthirteen, TH_3_2,
                                          iv_length) in
           let plaintext_3a_2:bitstring=decxor(m3_2, KEYSTREAM_3_2) in
           let (ID_CRED_PSK_in_2:bitstring, ciphertext_3b_2:bitstring)=plaintext_3a_2 in
           let (=ID_CRED_PSK_in_2)=ID_CRED_PSK_2 in 
               (let external_aad_3_2:bitstring=(ID_CRED_PSK_2, (TH_3_2, (CRED_I_2, CRED_R_2))) in
                let ad_3_2:bitstring=(sEncrypt0, (sempty, external_aad_3_2)) in
                let plaintext_3b_2:bitstring=aeaddec(ciphertext_3b_2, K_3_2, IV_3_2,
                                                     ad_3_2) in
                let EAD_3_2:bitstring=plaintext_3b_2 in
                let TH_4_2:bitstring=hash((wrap(TH_3_2), (ID_CRED_PSK_2, (plaintext_3b_2, (CRED_I_2, CRED_R_2))))) in
                let K_4_2:bitstring=edhoc_kdf(PRK_4e3m_2, seight, TH_4_2, key_length) in
                let IV_4_2:bitstring=edhoc_kdf(PRK_3e2m_2, snine, TH_4_2, iv_length) in
                let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                  hash_length) in
                let external_aad_4_2:bitstring=TH_4_2 in
                let ad_4_2:bitstring=(sEncrypt0, (sempty, external_aad_4_2)) in
                let m4_2:bitstring=aeadenc(EAD_4_2, K_4_2, IV_4_2, ad_4_2) in
                event eDerivedR( cid_2, PRK_out_2, Y_2, G_X_2, psk_2 );
                event eTransmitEAD( m4_2, EAD_4_2, PRK_out_2 );
                event eAcceptR( cid_2, method_2, subject_i_2, subject_r_2, PRK_out_2,
                                G_X_2, Y_2, psk_2
                      );
                event eAcceptRData( PRK_out_2, method_2, subject_i_2, subject_r_2, psk_2,
                                    Y_2, G_X_2,
                                    (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3a_2)))))))))
                      );
                event eFinishR( cid_2, PRK_out_2 );
                out(att,m4_2);
                ((0)
               | (leakSKey(PRK_out_2))))))).
let compromise(psk_2:bitstring)=
    in(att,=sComp);
    event eCompromise( psk_2 );
    event eSharePSK( psk_2 );
    out(att,psk_2).
let LeakSubjectI(subj_i_2:bitstring)=
    in(att,=sComp);
    event eExposeSubjectI( subj_i_2 );
    out(att,subj_i_2).
let LeakSubjectR(subj_r_2:bitstring)=
    in(att,=sComp);
    event eExposeSubjectR( subj_r_2 );
    out(att,subj_r_2).


process
    !
    (new psk_4:bitstring;
     event eHonest( psk_4 );
     event eSharePSK( psk_4 );
     new cid_2:bitstring;
     new subject_i_4:bitstring;
     new subject_r_4:bitstring;
     event eHonestSubjectI( subject_i_4 );
     event eHonestSubjectR( subject_r_4 );
     let cred_i_2:bitstring=make_cred(subject_i_4, psk_4) in
     let cred_r_2:bitstring=make_cred(subject_r_4, psk_4) in
     let ID_CRED_PSK_2:bitstring=make_id(cred_i_2, cred_r_2, psk_4) in
     !
     (((I(cid_2, method_four, ID_CRED_PSK_2))
     | (!
        (((((((R(cid_2, ID_CRED_PSK_2))
            | (compromise(psk_4))))
          | (LeakSubjectI(subject_i_4))))
        | (LeakSubjectR(subject_r_4))))))))

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `secretR_psk' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "DerivedI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "SendIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "DerivedI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "InitiateWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "RespondWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `OnlyMethodFour' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

Formula terms
=============

  lemma `authR_injective' uses terms of the wrong form: `Free i',
    `Free j'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
  
  lemma `authI_injective' uses terms of the wrong form: `Free i',
    `Free j'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `secretR_psk' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretR_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `secretI_psk' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "DerivedI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthRI_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `honestauthIR_psk_non_inj' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authR_injective' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `authI_injective' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_I_to_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "AcceptRData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `data_authentication_R_to_I' references action 
    fact "SendIData" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_R_implies_I' references action 
    fact "DerivedI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `key_agreement_I_implies_R' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `weak_pfs' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "ExposeSubjectI" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "LeakSessionKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `strong_pfs' references action 
    fact "LeakShare" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `explicit_key_confirmation_I' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_I' references action 
    fact "InitiateWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `identity_binding_R' references action 
    fact "RespondWithID" (arity 2, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "AcceptI" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_I' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "AcceptR" (arity 8, Linear) 
  but no rule has such an action.
  
  lemma `no_passive_impersonation_R' references action 
    fact "Honest" (arity 1, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `OnlyMethodFour' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

Formula terms
=============

  lemma `authR_injective' uses terms of the wrong form: `Free i',
    `Free j'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
  
  lemma `authI_injective' uses terms of the wrong form: `Free i',
    `Free j'
  
  The only allowed terms are public names and bound node and message
  variables. If you encounter free message variables, then you might
  have forgotten a #-prefix. Sort prefixes can only be dropped where
  this is unambiguous. Moreover, reducible function symbols are
  disallowed.
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)
